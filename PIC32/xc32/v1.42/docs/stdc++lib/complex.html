<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 15.15), see www.w3.org">

  <title>&lt;complex&gt;</title>
</head>

<body>
  <h1><a name="&lt;complex&gt;"><code>&lt;complex&gt;</code></a></h1>
  <hr>

  <p><b><code><a href="#abs">abs</a> &middot; <a href="#arg">arg</a> &middot; <a href="#complex">complex</a>
  &middot; <a href="#complex%3Cdouble%3E">complex&lt;double&gt;</a> &middot; <a href=
  "#complex%3Cfloat%3E">complex&lt;float&gt;</a> &middot; <a href=
  "#complex%3Clong%20double%3E">complex&lt;long double&gt;</a> &middot; <a href="#conj">conj</a> &middot;
  <a href="#cos">cos</a> &middot; <a href="#cosh">cosh</a> &middot; <a href="#exp">exp</a> &middot; <a href=
  "#imag">imag</a> &middot; <a href="#log">log</a> &middot; <a href="#log10">log10</a> &middot; <a href=
  "#norm">norm</a> &middot; <a href="#operator!=">operator!=</a> &middot; <a href="#operator*">operator*</a>
  &middot; <a href="#operator+">operator+</a> &middot; <a href="#operator-">operator-</a> &middot; <a href=
  "#operator/">operator/</a> &middot; <a href="#operator%3C%3C">operator&lt;&lt;</a> &middot; <a href=
  "#operator==">operator==</a> &middot; <a href="#operator%3E%3E">operator&gt;&gt;</a> &middot; <a href=
  "#polar">polar</a> &middot; <a href="#pow">pow</a> &middot; <a href="#real">real</a> &middot; <a href=
  "#sin">sin</a> &middot; <a href="#sinh">sinh</a> &middot; <a href="#sqrt">sqrt</a> &middot; <a href=
  "#tan">tan</a> &middot; <a href="#tanh">tanh</a> &middot; <a href=
  "#__STD_COMPLEX">__STD_COMPLEX</a></code></b></p>
  <hr>

  <p>Include the standard header <b><code>&lt;complex&gt;</code></b> to define template class
  <code>complex</code> and a host of supporting template functions. Unless otherwise specified, functions
  that can return multiple values return an imaginary part in the half-open interval <code>(-pi,
  pi]</code>.</p>

  <p>Beginning with <b>C++0X</b>, some functions and constructors declared in this header use
  <code>constexpr</code> to signal that they are treated as compile-time constants.</p>

  <p>Many of the functions declared in this header have <b><a name="additional overloads">additional
  overloads</a></b>, which behave much like the generic functions defined in the C99 header
  <code>&lt;tgmath.h&gt;</code>. The following functions have such additional overloads:</p>
  <pre>
abs      conj     polar
acos     cos      pow
acosh    cosh     real
arg      exp      sin
asin     imag     sinh
asinh    log      sqrt
atan     log10    tan
atanh    norm     tanh
</pre>

  <p>These additional overloads are added with <a href="index.html#TR1">TR1</a></p>
  <hr>
  <pre>
namespace std {
#define <b><a href="#__STD_COMPLEX">__STD_COMPLEX</a></b>

        // TEMPLATE CLASSES
template&lt;class Ty&gt;
    class <b><a href="#complex">complex</a></b>;
template&lt;&gt;
    class <b><a href="#complex%3Cfloat%3E">complex&lt;float&gt;</a></b>;
template&lt;&gt;
    class <b><a href="#complex%3Cdouble%3E">complex&lt;double&gt;</a></b>;
template&lt;&gt;
    class <b><a href="#complex%3Clong%20double%3E">complex&lt;long double&gt;</a></b>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator+">operator+</a></b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator+">operator+</a></b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator+">operator+</a></b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator-">operator-</a></b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator-">operator-</a></b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator-">operator-</a></b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator*">operator*</a></b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator*">operator*</a></b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator*">operator*</a></b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator/">operator/</a></b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator/">operator/</a></b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator/">operator/</a></b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator+">operator+</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#operator-">operator-</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    bool <b><a href="#operator==">operator==</a></b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <b><a href="#operator==">operator==</a></b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    bool <b><a href="#operator==">operator==</a></b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <b><a href="#operator!=">operator!=</a></b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <b><a href="#operator!=">operator!=</a></b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    bool <b><a href="#operator!=">operator!=</a></b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty, class Elem, class Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <b><a href="#operator%3E%3E">operator&gt;&gt;</a></b>(basic_istream&lt;Elem, Tr&gt;&amp; istr,
            complex&lt;Ty&gt;&amp; right);
template&lt;class Ty, class Elem, class Tr&gt;
    basic_ostream&lt;Elem, Tr&gt;&amp;
        <b><a href="#operator%3C%3C">operator&lt;&lt;</a></b>(basic_ostream&lt;Elem, Tr&gt;&amp; ostr,
            const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    Ty <b><a href="#real">real</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    Ty <b><a href="#imag">imag</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    Ty <b><a href="#abs">abs</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    Ty <b><a href="#arg">arg</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    Ty <b><a href="#norm">norm</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#conj">conj</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#polar">polar</a></b>(const Ty&amp; rho, const Ty&amp; theta = 0);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#cos">cos</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#cosh">cosh</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#exp">exp</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#log">log</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#log10">log10</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#pow">pow</a></b>(const complex&lt;Ty&gt;&amp; left, const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#pow">pow</a></b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#pow">pow</a></b>(const Ty&amp; left, const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#sin">sin</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#sinh">sinh</a></b>(const complex&lt;Ty&gt;&amp; left);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b><a href="#sqrt">sqrt</a></b>(const complex&lt;Ty&gt;&amp; left);
}  // namespace std
</pre>

  <h2><a name="abs"><code>abs</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    Ty <b>abs</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the magnitude of <code>left</code>.</p>

  <h2><a name="arg"><code>arg</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    Ty <b>arg</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the phase angle of <code>left</code>.</p>

  <h2><a name="complex"><code>complex</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    class <b>complex</b> {
public:
    typedef Ty <b><a href="#complex::value_type">value_type</a></b>;

    Ty <b><a href="#complex::real">real</a></b>() const;
    void <b><a href="#complex::real">real</a></b>(Ty val);
    Ty <b><a href="#complex::imag">imag</a></b>() const;
    void <b><a href="#complex::imag">imag</a></b>(Ty val);

    <b><a href="#complex::complex">complex</a></b>(const Ty&amp; realval = 0, const Ty&amp; imagval = 0);
    template&lt;class Other&gt;
        <b><a href="#complex::complex">complex</a></b>(const complex&lt;Other&gt;&amp; right);
    template&lt;class Other&gt;
        complex&amp; <b><a href=
"#complex::operator=">operator=</a></b>(const complex&lt;Other&gt;&amp; right);
    template&lt;class Other&gt;
        complex&amp; <b><a href=
"#complex::operator+=">operator+=</a></b>(const complex&lt;Other&gt;&amp; right);
    template&lt;class Other&gt;
        complex&amp; <b><a href=
"#complex::operator-=">operator-=</a></b>(const complex&lt;Other&gt;&amp; right);
    template&lt;class Other&gt;
        complex&amp; <b><a href=
"#complex::operator*=">operator*=</a></b>(const complex&lt;Other&gt;&amp; right);
    template&lt;class Other&gt;
        complex&amp; <b><a href=
"#complex::operator/=">operator/=</a></b>(const complex&lt;Other&gt;&amp; right);
    complex&amp; <b><a href="#complex::operator=">operator=</a></b>(const Ty&amp; right);
    complex&amp; <b><a href="#complex::operator+=">operator+=</a></b>(const Ty&amp; right);
    complex&amp; <b><a href="#complex::operator-=">operator-=</a></b>(const Ty&amp; right);
    complex&amp; <b><a href="#complex::operator*=">operator*=</a></b>(const Ty&amp; right);
    complex&amp; <b><a href="#complex::operator/=">operator/=</a></b>(const Ty&amp; right);
    };
</pre>

  <p>The template class describes an object that stores two objects of type <b><code>Ty</code></b>, one that
  represents the real part of a complex number and one that represents the imaginary part. An object of class
  <code>Ty</code>:</p>

  <ul>
    <li>has a public default constructor, destructor, copy constructor, and assignment operator -- with
    conventional behavior</li>

    <li>can be assigned integer or floating-point values, or type cast to such values -- with conventional
    behavior</li>

    <li>defines the arithmetic operators and math functions, as needed, that are defined for the
    floating-point types -- with conventional behavior</li>
  </ul>

  <p>In particular, no subtle differences may exist between copy construction and default construction
  followed by assignment. And none of the operations on objects of class <code>Ty</code> may throw
  exceptions.</p>

  <p>Explicit specializations of template class <code>complex</code> exist for the three floating-point
  types. In this <a href="index.html#implementation">implementation</a>, a value of any other type
  <code>Ty</code> is type cast to <i>double</i> for actual calculations, with the <i>double</i> result
  assigned back to the stored object of type <code>Ty</code>.</p>

  <h3><a name="complex::complex"><code>complex::complex</code></a></h3>
  <pre>
<b>complex</b>(const Ty&amp; realval = 0, const Ty&amp; imagval = 0);
template&lt;class Other&gt;
    <b>complex</b>(const complex&lt;Other&gt;&amp; right);
</pre>

  <p>The first constructor initializes the stored real part to <code>realval</code> and the stored imaginary
  part to <code>imagval</code>. The second constructor initializes the stored real part to
  <code>right.real()</code> and the stored imaginary part to <code>right.imag()</code>.</p>

  <h3><a name="complex::imag"><code>complex::imag</code></a></h3>
  <pre>
Ty <b>imag</b>() const;
void <b>imag</b>(Ty val);
</pre>

  <p>The first member function returns the stored imaginary part. The second member function stores
  <code>val</code> in the imaginary part.</p>

  <h3><a name="complex::operator*="><code>complex::operator*=</code></a></h3>
  <pre>
template&lt;class Other&gt;
    complex&amp; <b>operator*=</b>(const complex&lt;Other&gt;&amp; right);
complex&amp; <b>operator*=</b>(const Ty&amp; right);
</pre>

  <p>The first member function replaces the stored real and imaginary parts with those corresponding to the
  complex product of <code>*this</code> and <code>right</code>. It then returns <code>*this</code>.</p>

  <p>The second member function multiplies both the stored real part and the stored imaginary part with
  <code>right</code>. It then returns <code>*this</code>.</p>

  <h3><a name="complex::operator+="><code>complex::operator+=</code></a></h3>
  <pre>
template&lt;class Other&gt;
    complex&amp; <b>operator+=</b>(const complex&lt;Other&gt;&amp; right);
complex&amp; <b>operator+=</b>(const Ty&amp; right);
</pre>

  <p>The first member function replaces the stored real and imaginary parts with those corresponding to the
  complex sum of <code>*this</code> and <code>right</code>. It then returns <code>*this</code>.</p>

  <p>The second member function adds <code>right</code> to the stored real part. It then returns
  <code>*this</code>.</p>

  <h3><a name="complex::operator-="><code>complex::operator-=</code></a></h3>
  <pre>
template&lt;class Other&gt;
    complex&amp; <b>operator-=</b>(const complex&lt;Other&gt;&amp; right);
complex&amp; <b>operator-=</b>(const Ty&amp; right);
</pre>

  <p>The first member function replaces the stored real and imaginary parts with those corresponding to the
  complex difference of <code>*this</code> and <code>right</code>. It then returns <code>*this</code>.</p>

  <p>The second member function subtracts <code>right</code> from the stored real part. It then returns
  <code>*this</code>.</p>

  <h3><a name="complex::operator/="><code>complex::operator/=</code></a></h3>
  <pre>
template&lt;class Other&gt;
    complex&amp; <b>operator/=</b>(const complex&lt;Other&gt;&amp; right);
complex&amp; <b>operator/=</b>(const Ty&amp; right);
</pre>

  <p>The first member function replaces the stored real and imaginary parts with those corresponding to the
  complex quotient of <code>*this</code> and <code>right</code>. It then returns <code>*this</code>.</p>

  <p>The second member function multiplies both the stored real part and the stored imaginary part with
  <code>right</code>. It then returns <code>*this</code>.</p>

  <h3><a name="complex::operator="><code>complex::operator=</code></a></h3>
  <pre>
template&lt;class Other&gt;
    complex&amp; <b>operator=</b>(const complex&lt;Other&gt;&amp; right);
complex&amp; <b>operator=</b>(const Ty&amp; right);
</pre>

  <p>The first member function replaces the stored real part with <code>right.real()</code> and the stored
  imaginary part with <code>right.imag()</code>. It then returns <code>*this</code>.</p>

  <p>The second member function replaces the stored real part with <code>right</code> and the stored
  imaginary part with zero. It then returns <code>*this</code>.</p>

  <h3><a name="complex::real"><code>complex::real</code></a></h3>
  <pre>
Ty <b>real</b>() const;
void <b>real</b>(Ty val);
</pre>

  <p>The first member function returns the stored real part. The second member function stores
  <code>val</code> in the real part.</p>

  <h3><a name="complex::value_type"><code>complex::value_type</code></a></h3>
  <pre>
typedef Ty <b>value_type</b>;
</pre>

  <p>The type is a synonym for the template parameter <code>Ty</code>.</p>

  <h2><a name="complex&lt;double&gt;"><code>complex&lt;double&gt;</code></a></h2>
  <pre>
template&lt;&gt;
    class <b>complex&lt;double&gt;</b> {
public:
    constexpr <b>complex</b>(double realval = 0, double imagval = 0);
    constexpr <b>complex</b>(const complex&lt;float&gt;&amp; right);
    constexpr explicit <b>complex</b>(const complex&lt;long double&gt;&amp; right);

    constexpr double real() const;
    constexpr double imag() const;
// rest same as template class complex
    };
</pre>

  <p>The explicitly specialized template class describes an object that stores two objects of type
  <i>double,</i> one that represents the real part of a complex number and one that represents the imaginary
  part. The explicit specialization differs only in the constructors it defines. The first constructor
  initializes the stored real part to <code>realval</code> and the stored imaginary part to
  <code>imagval</code>. The remaining two constructors initialize the stored real part to
  <code>right.real()</code> and the stored imaginary part to <code>right.imag()</code>.</p>

  <h2><a name="complex&lt;float&gt;"><code>complex&lt;float&gt;</code></a></h2>
  <pre>
template&lt;&gt;
    class <b>complex&lt;float&gt;</b> {
public:
    constexpr <b>complex</b>(float realval = 0, float imagval = 0);
    constexpr explicit <b>complex</b>(const complex&lt;double&gt;&amp; right);
    constexpr explicit <b>complex</b>(const complex&lt;long double&gt;&amp; right);

    constexpr float real() const;
    constexpr float imag() const;
// rest same as template class complex
    };
</pre>

  <p>The explicitly specialized template class describes an object that stores two objects of type
  <i>float,</i> one that represents the real part of a complex number and one that represents the imaginary
  part. The explicit specialization differs only in the constructors it defines. The first constructor
  initializes the stored real part to <code>realval</code> and the stored imaginary part to
  <code>imagval</code>. The remaining two constructors initialize the stored real part to
  <code>right.real()</code> and the stored imaginary part to <code>right.imag()</code>.</p>

  <h2><a name="complex&lt;long double&gt;"><code>complex&lt;long double&gt;</code></a></h2>
  <pre>
template&lt;&gt;
    class <b>complex&lt;long double&gt;</b> {
public:
    constexpr <b>complex</b>(long double realval = 0, long double imagval = 0);
    constexpr <b>complex</b>(const complex&lt;float&gt;&amp; right);
    constexpr <b>complex</b>(const complex&lt;double&gt;&amp; right);

    constexpr long double real() const;
    constexpr long double imag() const;
// rest same as template class complex
    };
</pre>

  <p>The explicitly specialized template class describes an object that stores two objects of type <i>long
  double,</i> one that represents the real part of a complex number and one that represents the imaginary
  part. The explicit specialization differs only in the constructors it defines. The first constructor
  initializes the stored real part to <code>realval</code> and the stored imaginary part to
  <code>imagval</code>. The remaining two constructors initialize the stored real part to
  <code>right.real()</code> and the stored imaginary part to <code>right.imag()</code>.</p>

  <h2><a name="conj"><code>conj</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>conj</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the conjugate of <code>left</code>.</p>

  <h2><a name="cos"><code>cos</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>cos</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the cosine of <code>left</code>.</p>

  <h2><a name="cosh"><code>cosh</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>cosh</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the hyperbolic cosine of <code>left</code>.</p>

  <h2><a name="exp"><code>exp</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>exp</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the exponential of <code>left</code>.</p>

  <h2><a name="imag"><code>imag</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    Ty <b>imag</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the imaginary part of <code>left</code>.</p>

  <h2><a name="log"><code>log</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>log</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the logarithm of <code>left</code>. The branch cuts are along the negative real
  axis.</p>

  <h2><a name="log10"><code>log10</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>log10</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the base 10 logarithm of <code>left</code>. The branch cuts are along the negative
  real axis.</p>

  <h2><a name="norm"><code>norm</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    Ty <b>norm</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the squared magnitude of <code>left</code>.</p>

  <h2><a name="operator!="><code>operator!=</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    bool <b>operator!=</b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <b>operator!=</b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    bool <b>operator!=</b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
</pre>

  <p>The operators each return true only if <code><a href="#real">real</a>(left) != real(right) || <a href=
  "#imag">imag</a>(left) != imag(right)</code>.</p>

  <h2><a name="operator*"><code>operator*</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator*</b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator*</b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator*</b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
</pre>

  <p>The operators each convert both operands to the return type, then return the complex product of the
  converted <code>left</code> and <code>right</code>.</p>

  <h2><a name="operator+"><code>operator+</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator+</b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator+</b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator+</b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator+</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The binary operators each convert both operands to the return type, then return the complex sum of the
  converted <code>left</code> and <code>right</code>.</p>

  <p>The unary operator returns <code>left</code>.</p>

  <h2><a name="operator-"><code>operator-</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator-</b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator-</b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator-</b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator-</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The binary operators each convert both operands to the return type, then return the complex difference
  of the converted <code>left</code> and <code>right</code>.</p>

  <p>The unary operator returns a value whose real part is <code>-<a href="#real">real</a>(left)</code> and
  whose imaginary part is <code>-<a href="#imag">imag</a>(left)</code>.</p>

  <h2><a name="operator/"><code>operator/</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator/</b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator/</b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>operator/</b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
</pre>

  <p>The operators each convert both operands to the return type, then return the complex quotient of the
  converted <code>left</code> and <code>right</code>.</p>

  <h2><a name="operator&lt;&lt;"><code>operator&lt;&lt;</code></a></h2>
  <pre>
template&lt;class Ty, class Elem, class Tr&gt;
    basic_ostream&lt;Elem, Tr&gt;&amp;
        <b><a href="#operator%3C%3C">operator&lt;&lt;</a></b>(basic_ostream&lt;Elem, Tr&gt;&amp; ostr,
            const complex&lt;Ty&gt;&amp; right);
</pre>

  <p>The template function inserts the complex value <code>right</code> in the output stream <code>os</code>,
  effectively by executing:</p>
  <pre>
basic_ostringstream&lt;Elem, Tr&gt; osstr;
osstr.flags(ostr.flags());
osstr.imbue(ostr.imbue());
osstr.precision(ostr.precision());
osstr &lt;&lt; '(' &lt;&lt; real(right) &lt;&lt; ','
    &lt;&lt; imag(right) &lt;&lt; ')';
ostr &lt;&lt; osstr.str().c_str();
</pre>

  <p>Thus, if <code>ostr.<a href="ios.html#ios_base::width">width</a>()</code> is greater than zero, any
  padding occurs either before or after the parenthesized pair of values, which itself contains no padding.
  The function returns <code>ostr</code>.</p>

  <h2><a name="operator=="><code>operator==</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    bool <b>operator==</b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    bool <b>operator==</b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    bool <b>operator==</b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
</pre>

  <p>The operators each return true only if <code><a href="#real">real</a>(left) == real(right) &amp;&amp;
  <a href="#imag">imag</a>(left) == imag(right)</code>.</p>

  <h2><a name="operator&gt;&gt;"><code>operator&gt;&gt;</code></a></h2>
  <pre>
template&lt;class Ty, class Elem, class Tr&gt;
    basic_istream&lt;Elem, Tr&gt;&amp;
        <b>operator&gt;&gt;</b>(basic_istream&lt;Elem, Tr&gt;&amp; istr,
            complex&lt;Ty&gt;&amp; right);
</pre>

  <p>The template function attempts to extract a complex value from the input stream <code>istr</code>,
  effectively by executing:</p>
  <pre>
istr &gt;&gt; ch &amp;&amp; ch == '('
    &amp;&amp; istr &gt;&gt; re &gt;&gt; ch &amp;&amp; ch == ','
    &amp;&amp; istr &gt;&gt; im &gt;&gt; ch &amp;&amp; ch == ')'
</pre>

  <p>Here, <code>ch</code> is an object of type <code>Elem</code>, and <code>re</code> and <code>im</code>
  are objects of type <code>Ty</code>.</p>

  <p>If the result of this expression is true, the function stores <code>re</code> in the real part and
  <code>im</code> in the imaginary part of <code>right</code>. In any event, the function returns
  <code>istr</code>.</p>

  <h2><a name="polar"><code>polar</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>polar</b>(const Ty&amp; rho,
        const Ty&amp; theta = 0);
</pre>

  <p>The function returns the complex value whose magnitude is <code>rho</code> and whose phase angle is
  <code>theta</code>.</p>

  <h2><a name="pow"><code>pow</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>pow</b>(const complex&lt;Ty&gt;&amp; left,
        const Ty&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>pow</b>(const complex&lt;Ty&gt;&amp; left,
        const complex&lt;Ty&gt;&amp; right);
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>pow</b>(const Ty&amp; left,
        const complex&lt;Ty&gt;&amp; right);
</pre>

  <p>The functions each effectively convert both operands to the return type, then return the converted
  <code>left</code> to the power <code>right</code>. The branch cut for <code>left</code> is along the
  negative real axis.</p>

  <h2><a name="real"><code>real</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    Ty <b>real</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the real part of <code>left</code>.</p>

  <h2><a name="sin"><code>sin</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>sin</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the sine of <code>left</code>.</p>

  <h2><a name="sinh"><code>sinh</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>sinh</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the hyperbolic sine of <code>left</code>.</p>

  <h2><a name="sqrt"><code>sqrt</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>sqrt</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the square root of <code>left</code>, with phase angle in the half-open interval
  <code>(-pi/2, pi/2]</code>. The branch cuts are along the negative real axis.</p>

  <h2><a name="__STD_COMPLEX"><code>__STD_COMPLEX</code></a></h2>
  <pre>
#define <b>__STD_COMPLEX</b>
</pre>

  <p>The macro is defined, with an unspecified expansion, to indicate compliance with the specifications of
  this header.</p>

  <h2><a name="tan"><code>tan</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>tan</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the tangent of <code>left</code>.</p>

  <h2><a name="tanh"><code>tanh</code></a></h2>
  <pre>
template&lt;class Ty&gt;
    complex&lt;Ty&gt; <b>tanh</b>(const complex&lt;Ty&gt;&amp; left);
</pre>

  <p>The function returns the hyperbolic tangent of <code>left</code>.</p>
  <hr>

  <p>See also the <b><a href="index.html#Table%20of%20Contents">Table of Contents</a></b> and the <b><a href=
  "_index.html">Index</a></b>.</p>

  <p><i><a href="crit_pjp.html">Copyright</a> &copy; 1992-2010 by P.J. Plauger. All rights reserved.</i></p>
  <!--V5.30:126I-->
</body>
</html>
