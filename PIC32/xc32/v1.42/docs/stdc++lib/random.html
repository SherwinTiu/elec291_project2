<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 15.15), see www.w3.org">

  <title>&lt;random&gt;</title>
</head>

<body>
  <h1><code><a name="&lt;random&gt;">&lt;random&gt;</a></code></h1>

  <p>[added with <a href="index.html#TR1">TR1</a>]</p>
  <hr>

  <p><b><code><a href="#bernoulli_distribution">bernoulli_distribution</a> &middot; <a href=
  "#binomial_distribution">binomial_distribution</a> &middot; <a href="#discard_block">discard_block</a>
  &middot; <a href="#exponential_distribution">exponential_distribution</a> &middot; <a href=
  "#gamma_distribution">gamma_distribution</a> &middot; <a href=
  "#geometric_distribution">geometric_distribution</a> &middot; <a href=
  "#linear_congruential">linear_congruential</a> &middot; <a href="#mersenne_twister">mersenne_twister</a>
  &middot; <a href="#minstd_rand0">minstd_rand0</a> &middot; <a href="#minstd_rand">minstd_rand</a> &middot;
  <a href="#mt19937">mt19937</a> &middot; <a href="#normal_distribution">normal_distribution</a> &middot;
  <a href="#operator_ne">operator!=</a> &middot; <a href="#operator_eq">operator==</a> &middot; <a href=
  "#operator_lsh">operator&lt;&lt;</a> &middot; <a href="#operator_rsh">operator&gt;&gt;</a> &middot;
  <a href="#poisson_distribution">poisson_distribution</a> &middot; <a href=
  "#random_device">random_device</a> &middot; <a href="#ranlux_base_01">ranlux_base_01</a> &middot; <a href=
  "#ranlux3">ranlux3</a> &middot; <a href="#ranlux3_01">ranlux3_01</a> &middot; <a href=
  "#ranlux4">ranlux4</a> &middot; <a href="#ranlux4_01">ranlux4_01</a> &middot; <a href=
  "#ranlux64_base_01">ranlux64_base_01</a> &middot; <a href="#subtract_with_carry">subtract_with_carry</a>
  &middot; <a href="#subtract_with_carry_01">subtract_with_carry_01</a> &middot; <a href=
  "#uniform_int">uniform_int</a> &middot; <a href="#uniform_real">uniform_real</a> &middot; <a href=
  "#variate_generator">variate_generator</a> &middot; <a href="#xor_combine">xor_combine</a></code></b></p>

  <p><b><code><a href="#cauchy_distribution">cauchy_distribution</a> &middot; <a href=
  "#chi_squared_distribution">chi_squared_distribution</a> &middot; <a href=
  "#default_random_engine">default_random_engine</a> &middot; <a href=
  "#discard_block_engine">discard_block_engine</a> &middot; <a href=
  "#discrete_distribution">discrete_distribution</a> &middot; <a href=
  "#extreme_value_distribution">extreme_value_distribution</a> &middot; <a href=
  "#fisher_f_distribution">fisher_f_distribution</a> &middot; <a href=
  "#generate_canonical">generate_canonical</a> &middot; <a href=
  "#independent_bits_engine">independent_bits_engine</a> &middot; <a href="#knuth_b">knuth_b</a> &middot;
  <a href="#linear_congruential_engine">linear_congruential_engine</a> &middot; <a href=
  "#lognormal_distribution">lognormal_distribution</a> &middot; <a href=
  "#mersenne_twister_engine">mersenne_twister_engine</a> &middot; <a href="#mt19937_64">mt19937_64</a>
  &middot; <a href="#negative_binomial_distribution">negative_binomial_distribution</a> &middot; <a href=
  "#piecewise_constant_distribution">piecewise_constant_distribution</a> &middot; <a href=
  "#piecewise_linear_distribution">piecewise_linear_distribution</a> &middot; <a href=
  "#ranlux24">ranlux24</a> &middot; <a href="#ranlux24_base">ranlux24_base</a> &middot; <a href=
  "#ranlux48">ranlux48</a> &middot; <a href="#ranlux48_base">ranlux48_base</a> &middot; <a href=
  "#seed_seq">seed_seq</a> &middot; <a href="#shuffle_order_engine">shuffle_order_engine</a> &middot;
  <a href="#student_t_distribution">student_t_distribution</a> &middot; <a href=
  "#subtract_with_carry_engine">subtract_with_carry_engine</a> &middot; <a href=
  "#uniform_int_distribution">uniform_int_distribution</a> &middot; <a href=
  "#uniform_real_distribution">uniform_real_distribution</a> &middot; <a href=
  "#weibull_distribution">weibull_distribution</a></code></b></p>
  <hr>

  <p>Include the <a href="index.html#TR1">TR1</a> header <b><code>&lt;random&gt;</code></b> to define a host
  of <a href="lib_rand.html#random%20number%20generator">random number generators</a>.</p>
  <pre>
namespace std {
    namespace tr1 {
    // UTILITIES
template&lt;class RealType,
    size_t bits,
    class Engine&gt;
    RealType <b><a href=
"#generate_canonical">generate_canonical</a></b>(Engine&amp; gen); <b>[added with C++0X]</b>
class <b><a href="#seed_seq">seed_seq</a></b>; <b>[added with C++0X]</b>

template&lt;class Engine,
    class Dist&gt;
    class <b><a href="#variate_generator">variate_generator</a></b>;

    // SIMPLE ENGINES
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <b><a href="#linear_congruential">linear_congruential</a></b>;
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    class <b><a href="#mersenne_twister">mersenne_twister</a></b>;
template&lt;class IntType,
    IntType M, int S, int R&gt;
    class <b><a href="#subtract_with_carry">subtract_with_carry</a></b>;
template&lt;class RealType,
    int W, int S, int R&gt;
    class <b><a href="#subtract_with_carry_01">subtract_with_carry_01</a></b>;
class <b><a href="#random_device">random_device</a></b>;

template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <b><a href=
"#linear_congruential_engine">linear_congruential_engine</a></b>; <b>[added with C++0X]</b>
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U,
    UIntType D, int S,
    UIntType B, int T,
    UIntType C, int L,
    UIntType F&gt;
    class <b><a href="#mersenne_twister_engine">mersenne_twister_engine</a></b>; <b>[added with C++0X]</b>
template&lt;class IntType,
    int W, int S, int R&gt;
    class <b><a href=
"#subtract_with_carry_engine">subtract_with_carry_engine</a></b>; <b>[added with C++0X]</b>

    // COMPOUND ENGINES
template&lt;class Engine,
    int P, int R&gt;
    class <b><a href="#discard_block">discard_block</a></b>;
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    class <b><a href="#xor_combine">xor_combine</a></b>;

template&lt;class Engine,
    size_t P, size_t R&gt;
    class <b><a href="#discard_block_engine">discard_block_engine</a></b>; <b>[added with C++0X]</b>
template&lt;class Engine,
    size_t W, class UIntType&gt;
    class <b><a href="#independent_bits_engine">independent_bits_engine</a></b>; <b>[added with C++0X]</b>
template&lt;class Engine,
    size_t K&gt;
    class <b><a href="#shuffle_order_engine">shuffle_order_engine</a></b>; <b>[added with C++0X]</b>

    // ENGINES WITH PREDEFINED PARAMETERS
typedef linear_congruential&lt;<i>ui-type</i>, 16807, 0, 2147483647&gt; <b><a href=
"#minstd_rand0">minstd_rand0</a></b>;
typedef linear_congruential&lt;<i>ui-type</i>, 48271, 0, 2147483647&gt; <b><a href=
"#minstd_rand">minstd_rand</a></b>;
typedef mersenne_twister&lt;<i>ui-type</i>, 32, 624, 397, 31,
    0x9908b0df, 11, 7, 0x9d2c5680, 15, 0xefc60000, 18&gt; <b><a href="#mt19937">mt19937</a></b>;
typedef mersenne_twister_engine&lt;<i>ui-type</i>, 64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29, 0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37, 0x0ff7eee000000000ULL, 43,
    6364136223846793005ULL&gt; <b><a href="#mt19937_64">mt19937_64</a></b> <b>[added with C++0X]</b>;
typedef subtract_with_carry_01&lt;float, 24, 10, 24&gt; <b><a href="#ranlux_base_01">ranlux_base_01</a></b>;
typedef subtract_with_carry_01&lt;double, 48, 10, 24&gt; <b><a href=
"#ranlux64_base_01">ranlux64_base_01</a></b>;
typedef discard_block&lt;subtract_with_carry&lt;<i>ui-type</i>, 1 &lt;&lt; 24, 10, 24&gt;,
    223, 24&gt; <b><a href="#ranlux3">ranlux3</a></b>;
typedef discard_block&lt;subtract_with_carry&lt;<i>ui-type</i>, 1 &lt;&lt; 24, 10, 24&gt;,
    389, 24&gt; <b><a href="#ranlux4">ranlux4</a></b>;
typedef discard_block&lt;ranlux_base_01, 223, 24&gt; <b><a href="#ranlux3_01">ranlux3_01</a></b>;
typedef discard_block&lt;ranlux_base_01, 389, 24&gt; <b><a href="#ranlux4_01">ranlux4_01</a></b>;

typedef shuffle_order_engine&lt;minstd_rand0, 256&gt;
    <b><a href="#knuth_b">knuth_b</a></b>; <b>[added with C++0X]</b>
typedef subtract_with_carry_engine&lt;<i>ui-type</i>, 24, 10, 24&gt;
    <b><a href="#ranlux24_base">ranlux24_base</a></b>; <b>[added with C++0X]</b>
typedef discard_block_engine&lt;ranlux_24_base, 223, 23&gt;
    <b><a href="#ranlux24">ranlux24</a></b>; <b>[added with C++0X]</b>
typedef subtract_with_carry_engine&lt;<i>ui-type</i>, 48, 5, 12&gt;
    <b><a href="#ranlux48_base">ranlux48_base</a></b>; <b>[added with C++0X]</b>
typedef discard_block_engine&lt;ranlux_48_base, 389, 11&gt;
    <b><a href="#ranlux48">ranlux48</a></b>; <b>[added with C++0X]</b>

typedef Rand <b><a href="#default_random_engine">default_random_engine</a></b>; <b>[added with C++0X]</b>

    // DISTRIBUTIONS
template&lt;class RealType = double&gt;
    class <b><a href="#bernoulli_distribution">bernoulli_distribution</a></b>;
template&lt;class IntType = int, class RealType = double&gt;
    class <b><a href="#binomial_distribution">binomial_distribution</a></b>;
template&lt;class IntType = int, class RealType = double&gt;
    class <b><a href="#geometric_distribution">geometric_distribution</a></b>;
template&lt;class IntType = int, class RealType = double&gt;
    class <b><a href="#poisson_distribution">poisson_distribution</a></b>;
template&lt;class IntType = int&gt;
    class <b><a href="#uniform_int">uniform_int</a></b>;

template&lt;class RealType = double&gt;
    class <b><a href="#exponential_distribution">exponential_distribution</a></b>;
template&lt;class RealType = double&gt;
    class <b><a href="#gamma_distribution">gamma_distribution</a></b>;
template&lt;class RealType = double&gt;
    class <b><a href="#normal_distribution">normal_distribution</a></b>;
template&lt;class RealType = double&gt;
    class <b><a href="#uniform_real">uniform_real</a></b>;

template&lt;class IntType = int&gt;
    class <b><a href="#discrete_distribution">discrete_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class IntType = int&gt;
    class <b><a href=
"#negative_binomial_distribution">negative_binomial_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class IntType = int&gt;
    class <b><a href="#uniform_int_distribution">uniform_int_distribution</a></b>; <b>[added with C++0X]</b>

template&lt;class RealType = double&gt;
    class <b><a href="#cauchy_distribution">cauchy_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href="#chi_squared_distribution">chi_squared_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href=
"#extreme_value_distribution">extreme_value_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href="#fisher_f_distribution">fisher_f_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href="#lognormal_distribution">lognormal_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href=
"#piecewise_constant_distribution">piecewise_constant_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href=
"#piecewise_linear_distribution">piecewise_linear_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href="#student_t_distribution">student_t_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href=
"#uniform_real_distribution">uniform_real_distribution</a></b>; <b>[added with C++0X]</b>
template&lt;class RealType = double&gt;
    class <b><a href="#weibull_distribution">weibull_distribution</a></b>; <b>[added with C++0X]</b>

    // OPERATORS
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <b><a href="#operator_eq">operator==</a></b>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <b><a href="#operator_eq">operator==</a></b>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <b><a href="#operator_eq">operator==</a></b>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <b><a href="#operator_eq">operator==</a></b>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <b><a href="#operator_eq">operator==</a></b>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <b><a href="#operator_eq">operator==</a></b>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <b><a href="#operator_eq">operator==</a></b>( <b>[added with C++0X]</b>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <b><a href="#operator_eq">operator==</a></b>( <b>[added with C++0X]</b>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <b><a href="#operator_eq">operator==</a></b>( <b>[added with C++0X]</b>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <b><a href="#operator_eq">operator==</a></b>( <b>[added with C++0X]</b>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <b><a href="#operator_eq">operator==</a></b>( <b>[added with C++0X]</b>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <b><a href="#operator_eq">operator==</a></b>( <b>[added with C++0X]</b>
        const ahuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>( <b>[added with C++0X]</b>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>( <b>[added with C++0X]</b>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>( <b>[added with C++0X]</b>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>( <b>[added with C++0X]</b>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>( <b>[added with C++0X]</b>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <b><a href="#operator_ne">operator!=</a></b>( <b>[added with C++0X]</b>
        const ahuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_lsh">operator&lt;&lt;</a></b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_lsh">operator&lt;&lt;</a></b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const weibull_distribution&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href="#operator_rsh">operator&gt;&gt;</a></b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, R&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b><a href=
"#operator_rsh">operator&gt;&gt;</a></b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        weibull_distribution&lt;RealType&gt;&amp; right);
    }  // namespace tr1
using tr1::bernoulli_distribution; <b>[added with C++0X]</b>
using tr1::binomial_distribution;
using tr1::discard_block; using tr1::exponential_distribution;
using tr1::gamma_distribution; using tr1::geometric_distribution;
using tr1::linear_congruential; using tr1::mersenne_twister;
using tr1::minstd_rand; using tr1::minstd_rand0;
using tr1::mt19937; using tr1::normal_distribution;
using tr1::poisson_distribution; using tr1::random_device;
using tr1::ranlux4; using tr1::ranlux3;
using tr1::ranlux3_01; using tr1::ranlux4;
using tr1::ranlux4_01; using tr1::ranlux64_base_01;
using tr1::ranlux_base_01; using tr1::subtract_with_carry;
using tr1::subtract_with_carry_01; using tr1::uniform_int;
using tr1::uniform_real; using tr1::variate_generator;
using tr1::xor_combine;

using tr1::cauchy_distribution; using tr1::chi_squared_distribution;
using tr1::discard_block_engine; using tr1::discrete_distribution;
using tr1::extreme_value_distribution; using tr1::fisher_f_distribution;
using tr1::generate_canonical;
using tr1::knuth_b; using tr1::independent_bits_engine;
using tr1::linear_congruential_engine; using tr1::lognormal_distribution;
using tr1::mersenne_twister_engine; using tr1::mt19937_64; 
using tr1::negative_binomial_distribution;
using tr1::piecewise_constant_distribution; piecewise_linear_distribution;
using tr1::ranlux24; using tr1::ranlux24_base; using tr1::ranlux48;
using tr1::ranlux48_base; using tr1::seed_seq; 
using tr1::shuffle_order_engine; using tr1::student_t_distribution;
using tr1::subtract_with_carry_engine; 
using tr1::uniform_int_distribution; using tr1::uniform_real_distribution;
using tr1::weibull_distribution;
}  // namespace std
</pre>

  <h2><code><a name="bernoulli_distribution" id=
  "bernoulli_distribution">bernoulli_distribution</a></code></h2>
  <pre>
class <b>bernoulli_distribution</b> {
public:
    typedef int <b><a href=
"#bernoulli_distribution::input_type">input_type</a></b>; <b>[removed with C++0X]</b>
    struct <b><a href="#bernoulli_distribution::param_type">param_type</a></b>; <b>[added with C++0X]</b>

    explicit <b><a href=
"#bernoulli_distribution::bernoulli_distribution">bernoulli_distribution</a></b>(double p0 = 0.5);
    explicit <b><a href=
"#bernoulli_distribution::bernoulli_distribution">bernoulli_distribution</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    double <b><a href="#bernoulli_distribution::p">p</a></b>() const;
    param_type <b><a href="#bernoulli_distribution::param">param</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href=
"#bernoulli_distribution::param">param</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#bernoulli_distribution::min">min</a></b>() const; <b>[added with C++0X]</b>
    result_type <b><a href="#bernoulli_distribution::max">max</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href="#bernoulli_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#bernoulli_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#bernoulli_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0); <b>[added with C++0X]</b>

private:
    double <b>stored_p</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values of type
  <code>bool</code>, returning <code>true</code> with a probability given by the argument to the
  constructor.</p>

  <h3><code><a name="bernoulli_distribution::bernoulli_distribution" id=
  "bernoulli_distribution::bernoulli_distribution">bernoulli_distribution::bernoulli_distribution</a></code></h3>
  <pre>
<b>explicit bernoulli_distribution</b>(double p0 = 0.5);
explicit <b>bernoulli_distribution</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &le; p0 &amp;&amp; p0 &le;
  1.0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_p</code> holds the value
  <code>p0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="bernoulli_distribution::input_type" id=
  "bernoulli_distribution::input_type">bernoulli_distribution::input_type</a></code></h3>
  <pre>
typedef int <b>input_type</b>; <b>[removed with C++0X]</b>
</pre>

  <p>The type is a synonym for <code>int</code>.</p>

  <h3><code><a name="bernoulli_distribution::max" id=
  "bernoulli_distribution::max">bernoulli_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns <code>true</code>.</p>

  <h3><code><a name="bernoulli_distribution::min" id=
  "bernoulli_distribution::min">bernoulli_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns <code>false</code>.</p>

  <h3><code><a name="bernoulli_distribution::operator()">bernoulli_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integer values and returns <code>true</code> with probability given
  by the stored value <code>stored_p</code>.</p>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="bernoulli_distribution::p" id=
  "bernoulli_distribution::p">bernoulli_distribution::p</a></code></h3>
  <pre>
double <b>p</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_p</code>.</p>

  <h3><code><a name="bernoulli_distribution::param" id=
  "bernoulli_distribution::param">bernoulli_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const; <b>[added with C++0X]</b>
void <b>param</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="bernoulli_distribution::param_type" id=
  "bernoulli_distribution::param_type">bernoulli_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> { <b>[added with C++0X]</b>
    typedef bernoulli_distribution distribution_type;

    param_type(double p0 = 0.5);
    double p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="bernoulli_distribution::reset" id=
  "bernoulli_distribution::reset">bernoulli_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="bernoulli_distribution::result_type" id=
  "bernoulli_distribution::result_type">bernoulli_distribution::result_type</a></code></h3>
  <pre>
typedef bool <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>bool</code>.</p>

  <h2><code><a name="binomial_distribution" id="binomial_distribution">binomial_distribution</a></code></h2>
  <pre>
template&lt;class IntType = int,
    class RealType = double&gt; <b>[always double with C++0X]</b>
    class <b>binomial_distribution</b> {
public:
    typedef T1 <b><a href=
"#binomial_distribution::input_type">input_type</a></b>; <b>[removed with C++0X]</b>
    typedef IntType <b><a href="#binomial_distribution::result_type">result_type</a></b>;
    struct <b><a href="#binomial_distribution::param_type">param_type</a></b>; <b>[added with C++0X]</b>

    explicit <b><a href=
"#binomial_distribution::binomial_distribution">binomial_distribution</a></b>(result_type t0 = 1,
        RealType p0 = RealType(0.5));
    explicit <b><a href=
"#binomial_distribution::binomial_distribution">binomial_distribution</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#binomial_distribution::t">t</a></b>() const;
    RealType <b><a href="#binomial_distribution::p">p</a></b>() const;
    param_type <b><a href="#binomial_distribution::param">param</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href=
"#binomial_distribution::param">param</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#binomial_distribution::min">min</a></b>() const; <b>[added with C++0X]</b>
    result_type <b><a href="#binomial_distribution::max">max</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href="#binomial_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#binomial_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#binomial_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0); <b>[added with C++0X]</b>

private:
    result_type <b>stored_t</b>;  <i>// exposition only</i>
    RealType <b>stored_p</b>;     <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified integral type distributed with a binomial distribution.</p>

  <h3><code><a name="binomial_distribution::binomial_distribution" id=
  "binomial_distribution::binomial_distribution">binomial_distribution::binomial_distribution</a></code></h3>
  <pre>
<b>binomial_distribution</b>(result_type t0 = 1,
    RealType p0 = RealType(0.5));
explicit <b>binomial_distribution</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt;= t0 &amp;&amp; 0.0 &lt;= p0
  &amp;&amp; p0 &lt;= 1.0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_p</code> holds the value
  <code>p0</code> and whose stored value <code>stored_t</code> holds the value <code>t0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="binomial_distribution::input_type" id=
  "binomial_distribution::input_type">binomial_distribution::input_type</a></code></h3>
  <pre>
typedef T1 <b>input_type</b>; <b>[removed with C++0X]</b>
</pre>

  <p>The type is a synonym for the implementation-defined type <code>T1</code>.</p>

  <h3><code><a name="binomial_distribution::max" id=
  "binomial_distribution::max">binomial_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="binomial_distribution::min" id=
  "binomial_distribution::min">binomial_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="binomial_distribution::operator()">binomial_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns integral values with each value
  <code>i</code> occurring with probability:</p>
  <pre>
    <img src="binomial_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="binomial_distribution::p" id=
  "binomial_distribution::p">binomial_distribution::p</a></code></h3>
  <pre>
RealType <b>p</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_p</code>.</p>

  <h3><code><a name="binomial_distribution::param" id=
  "binomial_distribution::param">binomial_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const; <b>[added with C++0X]</b>
void <b>param</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="binomial_distribution::param_type" id=
  "binomial_distribution::param_type">binomial_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> { <b>[added with C++0X]</b>
    typedef binomial_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(result_type t0 = 1, RealType p0 = RealType(0.5));
    result_type t() const;
    RealType p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="binomial_distribution::reset" id=
  "binomial_distribution::reset">binomial_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="binomial_distribution::result_type" id=
  "binomial_distribution::result_type">binomial_distribution::result_type</a></code></h3>
  <pre>
typedef IntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h3><code><a name="binomial_distribution::t" id=
  "binomial_distribution::t">binomial_distribution::t</a></code></h3>
  <pre>
result_type <b>t</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_t</code>.</p>

  <h2><code><a name="cauchy_distribution" id="cauchy_distribution">cauchy_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>cauchy_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#cauchy_distribution::result_type">result_type</a></b>;
    struct <b><a href="#cauchy_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#cauchy_distribution::cauchy_distribution">cauchy_distribution</a></b>(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    explicit <b><a href=
"#cauchy_distribution::cauchy_distribution">cauchy_distribution</a></b>(const param_type&amp; par0);

    result_type <b><a href="#cauchy_distribution::a">a</a></b>() const;
    result_type <b><a href="#cauchy_distribution::b">b</a></b>() const;
    param_type <b><a href="#cauchy_distribution::param">param</a></b>() const;
    void <b><a href="#cauchy_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#cauchy_distribution::min">min</a></b>() const;
    result_type <b><a href="#cauchy_distribution::max">max</a></b>() const;
    void <b><a href="#cauchy_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#cauchy_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#cauchy_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <b>stored_a</b>;  <i>// exposition only</i>
    result_type <b>stored_b</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed with a Cauchy distribution.</p>

  <h3><code><a name="cauchy_distribution::a" id=
  "cauchy_distribution::a">cauchy_distribution::a</a></code></h3>
  <pre>
result_type <b>a</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_a</code>.</p>

  <h3><code><a name="cauchy_distribution::b" id=
  "cauchy_distribution::b">cauchy_distribution::b</a></code></h3>
  <pre>
result_type <b>b</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_b</code>.</p>

  <h3><code><a name="cauchy_distribution::cauchy_distribution" id=
  "cauchy_distribution::cauchy_distribution">cauchy_distribution::cauchy_distribution</a></code></h3>
  <pre>
<b>cauchy_distribution</b>(result_type a0 = result_type(0.0),
    result_type b0 = result_type(1.0));
explicit <b>cauchy_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; b0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_a</code> holds the value
  <code>a0</code> and whose stored value <code>stored_b</code> holds the value <code>b0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="cauchy_distribution::max" id=
  "cauchy_distribution::max">cauchy_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="cauchy_distribution::min" id=
  "cauchy_distribution::min">cauchy_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="cauchy_distribution::operator()">cauchy_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="cauchy_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="cauchy_distribution::param" id=
  "cauchy_distribution::param">cauchy_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="cauchy_distribution::param_type" id=
  "cauchy_distribution::param_type">cauchy_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef cauchy_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="cauchy_distribution::reset" id=
  "cauchy_distribution::reset">cauchy_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="cauchy_distribution::result_type" id=
  "cauchy_distribution::result_type">cauchy_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h2><code><a name="chi_squared_distribution" id=
  "chi_squared_distribution">chi_squared_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>chi_squared_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#chi_squared_distribution::result_type">result_type</a></b>;
    struct <b><a href="#chi_squared_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#chi_squared_distribution::chi_squared_distribution">chi_squared_distribution</a></b>(RealType n0 = 1);
    explicit <b><a href=
"#chi_squared_distribution::chi_squared_distribution">chi_squared_distribution</a></b>(const param_type&amp; par0);

    RealType <b><a href="#chi_squared_distribution::n">n</a></b>() const;
    param_type <b><a href="#chi_squared_distribution::param">param</a></b>() const;
    void <b><a href="#chi_squared_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#chi_squared_distribution::min">min</a></b>() const;
    result_type <b><a href="#chi_squared_distribution::max">max</a></b>() const;
    void <b><a href="#chi_squared_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#chi_squared_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#chi_squared_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <b>stored_n</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed with a chi-squared distribution.</p>

  <h3><code><a name="chi_squared_distribution::chi_squared_distribution" id=
  "chi_squared_distribution::chi_squared_distribution">chi_squared_distribution::chi_squared_distribution</a></code></h3>
  <pre>
<b>chi_squared_distribution</b>(RealType n0 = 1);
explicit <b>chi_squared_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; n0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_n</code> holds the value
  <code>n0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="chi_squared_distribution::max" id=
  "chi_squared_distribution::max">chi_squared_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="chi_squared_distribution::min" id=
  "chi_squared_distribution::min">chi_squared_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="chi_squared_distribution::n" id=
  "chi_squared_distribution::n">chi_squared_distribution::n</a></code></h3>
  <pre>
RealType <b>n</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_n</code>.</p>

  <h3><code><a name=
  "chi_squared_distribution::operator()">chi_squared_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="chi_squared_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="chi_squared_distribution::param" id=
  "chi_squared_distribution::param">chi_squared_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="chi_squared_distribution::param_type" id=
  "chi_squared_distribution::param_type">chi_squared_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef chi_squared_distribution&lt;RealType&gt; distribution_type;

    param_type(int n0 = 1);
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="chi_squared_distribution::reset" id=
  "chi_squared_distribution::reset">chi_squared_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="chi_squared_distribution::result_type" id=
  "chi_squared_distribution::result_type">chi_squared_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h2><code><a name="default_random_engine" id="default_random_engine">default_random_engine</a></code></h2>
  <pre>
typedef Rand <b>default_random_engine</b>; <b>[added with C++0X]</b>
</pre>

  <p>The type is a synonym for <code>Rand</code>, a predefined <a href="lib_rand.html#engine">engine</a>.</p>

  <h2><code><a name="discard_block" id="discard_block">discard_block</a></code></h2>
  <pre>
template&lt;class Engine,
    int P, int R&gt;
    class <b>discard_block</b> {
public:
    typedef Engine <b><a href="#discard_block::base_type">base_type</a></b>;
    typedef typename base_type::result_type <b><a href="#discard_block::result_type">result_type</a></b>;
    static constexpr int <b><a href="#discard_block::block_size">block_size</a></b> = P;
    static constexpr int <b><a href="#discard_block::used_block">used_block</a></b> = R;

    <b><a href="#discard_block::discard_block">discard_block</a></b>();
    explicit <b><a href="#discard_block::discard_block">discard_block</a></b>(const base_type&amp; eng);
    template&lt;class Gen&gt;
        <b><a href="#discard_block::discard_block">discard_block</a></b>(Gen&amp; gen);
    void <b><a href="#discard_block::seed">seed</a></b>();
    template&lt;class Gen&gt;
        void <b><a href="#discard_block::seed">seed</a></b>(Gen&amp; gen);

    const base_type&amp; <b><a href="#discard_block::base">base</a></b>() const;
    result_type <b><a href="#discard_block::min">min</a></b>() const;
    result_type <b><a href="#discard_block::max">max</a></b>() const;
    result_type <b><a href="#discard_block::operator()">operator()</a></b>();

private:
    Engine <b>stored_eng</b>;       <i>// exposition only</i>
    int <b>count</b>;               <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#compound%20engine">compound engine</a> that
  produces values by discarding some of the values returned by its base engine. Each cycle of the compound
  engine begins by returning <code>R</code> values successively produced by the base engine and ends by
  discarding <code>P - R</code> such values. The engine's <a href="lib_rand.html#state">state</a> is the
  state of <code>stored_eng</code> followed by the number of calls to <code>operator()</code> that have
  occurred since the beginning of the current cycle.</p>

  <p>The value of the template argument <code>R</code> must be less than or equal to the value of the
  template argument <code>P</code>.</p>

  <h3><code><a name="discard_block::base" id="discard_block::base">discard_block::base</a></code></h3>
  <pre>
const base_type&amp; <b>base</b>() const;
</pre>

  <p>The member function returns a reference to the underlying engine object.</p>

  <h3><code><a name="discard_block::base_type" id=
  "discard_block::base_type">discard_block::base_type</a></code></h3>
  <pre>
typedef Engine <b>base_type</b>;
</pre>

  <p>The type is a synonym for the type of the underlying engine object.</p>

  <h3><code><a name="discard_block::block_size" id=
  "discard_block::block_size">discard_block::block_size</a></code></h3>
  <pre>
static constexpr int <b>block_size</b> = P;
</pre>

  <p>The static const variable holds the value of the template argument <code>P</code>, the number of values
  in each cycle.</p>

  <h3><code><a name="discard_block::discard_block" id=
  "discard_block::discard_block">discard_block::discard_block</a></code></h3>
  <pre>
<b>discard_block</b>();
explicit <b>discard_block</b>(const base_type&amp; eng);
template&lt;class Gen&gt;
    <b>discard_block</b>(Gen&amp; gen);
</pre>

  <p>The first constructor constructs a <code>discard_block</code> object with a default-initialized engine.
  The second contructor constructs a <code>discard_block</code> object with a copy of an engine object. The
  third constructor constucts a <code>discard_block</code> object with an engine initialized from a
  generator.</p>

  <h3><code><a name="discard_block::max" id="discard_block::max">discard_block::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns <code>stored_eng.max()</code>.</p>

  <h3><code><a name="discard_block::min" id="discard_block::min">discard_block::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns <code>stored_eng.min()</code>.</p>

  <h3><code><a name="discard_block::operator()">discard_block::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function returns the next value in the sequence.</p>

  <h3><code><a name="discard_block::result_type" id=
  "discard_block::result_type">discard_block::result_type</a></code></h3>
  <pre>
typedef typename base_type::result_type <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>base_type::result_type</code>.</p>

  <h3><code><a name="discard_block::seed" id="discard_block::seed">discard_block::seed</a></code></h3>
  <pre>
void <b>seed</b>();
template&lt;class Gen&gt;
    void <b>seed</b>(Gen&amp; gen);
</pre>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> calls <code>stored_eng.seed()</code>
  and sets <code>count</code> to 0. The second seed function calls <code>stored_eng.seed(gen)</code> and sets
  <code>count</code> to 0.</p>

  <h3><code><a name="discard_block::used_block" id=
  "discard_block::used_block">discard_block::used_block</a></code></h3>
  <pre>
static constexpr int <b>used_block</b> = R;
</pre>

  <p>The static const variable holds the value of the template argument <code>R</code>, the number of values
  to return at the beginning of each cycle.</p>

  <h2><code><a name="discard_block_engine" id="discard_block_engine">discard_block_engine</a></code></h2>
  <pre>
template&lt;class Engine,
    int P, int R&gt;
    class <b>discard_block_engine</b> { <b>[added with C++0X]</b>
public:
    typedef Engine <b><a href="#discard_block_engine::base_type">base_type</a></b>;
    typedef typename base_type::result_type <b><a href=
"#discard_block_engine::result_type">result_type</a></b>;
    static constexpr int <b><a href="#discard_block_engine::block_size">block_size</a></b> = P;
    static constexpr int <b><a href="#discard_block_engine::used_block">used_block</a></b> = R;

    <b><a href="#discard_block_engine::discard_block_engine">discard_block_engine</a></b>();
    explicit <b><a href=
"#discard_block_engine::discard_block_engine">discard_block_engine</a></b>(const base_type&amp; eng);
    explicit <b><a href=
"#discard_block_engine::discard_block_engine">discard_block_engine</a></b>(result_type x0);
    explicit <b><a href=
"#discard_block_engine::discard_block_engine">discard_block_engine</a></b>(seed_seq&amp; seq);
    void <b><a href="#discard_block_engine::seed">seed</a></b>();
    void <b><a href="#discard_block_engine::seed">seed</a></b>(result_type x0);
    void <b><a href="#discard_block_engine::seed">seed</a></b>(seed_seq&amp; seq);

    const base_type&amp; <b><a href="#discard_block_engine::base">base</a></b>() const;
    static constexpr result_type <b><a href="#discard_block_engine::min">min</a></b>();
    static constexpr result_type <b><a href="#discard_block_engine::max">max</a></b>();
    result_type <b><a href="#discard_block_engine::operator()">operator()</a></b>();
    void <b><a href="#discard_block_engine::discard">discard</a></b>(unsigned long long count);

private:
    Engine <b>stored_eng</b>;       <i>// exposition only</i>
    int <b>count</b>;               <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#compound%20engine">compound engine</a> that
  produces values by discarding some of the values returned by its base engine. Each cycle of the compound
  engine begins by returning <code>R</code> values successively produced by the base engine and ends by
  discarding <code>P - R</code> such values. The engine's <a href="lib_rand.html#state">state</a> is the
  state of <code>stored_eng</code> followed by the number of calls to <code>operator()</code> that have
  occurred since the beginning of the current cycle.</p>

  <p>The value of the template argument <code>R</code> must be less than or equal to the value of the
  template argument <code>P</code>.</p>

  <h3><code><a name="discard_block_engine::base" id=
  "discard_block_engine::base">discard_block_engine::base</a></code></h3>
  <pre>
const base_type&amp; <b>base</b>() const;
</pre>

  <p>The member function returns a reference to the underlying engine object.</p>

  <h3><code><a name="discard_block_engine::base_type" id=
  "discard_block_engine::base_type">discard_block_engine::base_type</a></code></h3>
  <pre>
typedef Engine <b>base_type</b>;
</pre>

  <p>The type is a synonym for the type of the underlying engine object.</p>

  <h3><code><a name="discard_block_engine::block_size" id=
  "discard_block_engine::block_size">discard_block_engine::block_size</a></code></h3>
  <pre>
static constexpr int <b>block_size</b> = P;
</pre>

  <p>The static const variable holds the value of the template argument <code>P</code>, the number of values
  in each cycle.</p>

  <h3><code><a name="discard_block_engine::discard" id=
  "discard_block_engine::discard">discard_block_engine::discard</a></code></h3>
  <pre>
void <b>discard</b>(unsigned long long count);
</pre>

  <p>The member function effectively calls <code>(*this)()</code> <code>count</code> times.</p>

  <h3><code><a name="discard_block_engine::discard_block_engine" id=
  "discard_block_engine::discard_block_engine">discard_block_engine::discard_block_engine</a></code></h3>
  <pre>
<b>discard_block_engine</b>();
explicit <b>discard_block_engine</b>(const base_type&amp; eng);
explicit <b>discard_block_engine</b>(result_type x0);
explicit <b>discard_block_engine</b>(seed_seq&amp; seq);
</pre>

  <p>The first constructor constructs a <code>discard_block_engine</code> object with a default-initialized
  engine. The second contructor constructs a <code>discard_block_engine</code> object with a copy of an
  engine object. The third constructor constucts a <code>discard_block_engine</code> object with its engine
  initialized by <code>stored_engine(x0)</code>. The fourth constructor constucts a
  <code>discard_block_engine</code> object with its engine initialized by
  <code>stored_engine(seq)</code>.</p>

  <h3><code><a name="discard_block_engine::max" id=
  "discard_block_engine::max">discard_block_engine::max</a></code></h3>
  <pre>
static constexpr result_type <b>max</b>();
</pre>

  <p>The static member function returns <code>Engine::max()</code>.</p>

  <h3><code><a name="discard_block_engine::min" id=
  "discard_block_engine::min">discard_block_engine::min</a></code></h3>
  <pre>
static result_type <b>min</b>();
</pre>

  <p>The static member function returns <code>Engine::min()</code>.</p>

  <h3><code><a name="discard_block_engine::operator()">discard_block_engine::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function returns the next value in the sequence.</p>

  <h3><code><a name="discard_block_engine::result_type" id=
  "discard_block_engine::result_type">discard_block_engine::result_type</a></code></h3>
  <pre>
typedef typename base_type::result_type <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>base_type::result_type</code>.</p>

  <h3><code><a name="discard_block_engine::seed" id=
  "discard_block_engine::seed">discard_block_engine::seed</a></code></h3>
  <pre>
void <b>seed</b>();
void <b>seed</b>(result_type x0);
void <b>seed</b>(seed_seq&amp; seq);
</pre>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> calls <code>stored_eng.seed()</code>
  and sets <code>count</code> to 0. The second seed function calls <code>stored_eng.seed(x0)</code> and sets
  <code>count</code> to 0. The second seed function calls <code>stored_eng.seed(seq)</code> and sets
  <code>count</code> to 0.</p>

  <h3><code><a name="discard_block_engine::used_block" id=
  "discard_block_engine::used_block">discard_block_engine::used_block</a></code></h3>
  <pre>
static constexpr int <b>used_block</b> = R;
</pre>

  <p>The static const variable holds the value of the template argument <code>R</code>, the number of values
  to return at the beginning of each cycle.</p>

  <h2><code><a name="discrete_distribution" id="discrete_distribution">discrete_distribution</a></code></h2>
  <pre>
template&lt;class IntType = int&gt;
    class <b>discrete_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef IntType <b><a href="#discrete_distribution::result_type">result_type</a></b>;
    struct <b><a href="#discrete_distribution::param_type">param_type</a></b>;

    <b><a href="#discrete_distribution::discrete_distribution">discrete_distribution</a></b>();
    <b><a href=
"#discrete_distribution::discrete_distribution">discrete_distribution</a></b>(initializer_list&lt;double&gt; init);
    explicit <b><a href=
"#discrete_distribution::discrete_distribution">discrete_distribution</a></b>(const param_type&amp; par0);
    template&lt;class Fn&gt;
        <b><a href=
"#discrete_distribution::discrete_distribution">discrete_distribution</a></b>(size_t count,
            double low, double high, Fn func);
    explicit <b><a href=
"#discrete_distribution::discrete_distribution">discrete_distribution</a></b>(const param_type&amp; par0);

    std::vector&lt;double&gt; <b><a href=
"#discrete_distribution::probabilities">probabilities</a></b>() const;
    param_type <b><a href="#discrete_distribution::param">param</a></b>() const;
    void <b><a href="#discrete_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#discrete_distribution::min">min</a></b>() const;
    result_type <b><a href="#discrete_distribution::max">max</a></b>() const;
    void <b><a href="#discrete_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#discrete_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#discrete_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    std::vector&lt;double&gt; <b>stored_p</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified integral type distributed according to a uniform-width histogram of probabilities.</p>

  <p>Three distributions are very similar:</p>

  <ul>
    <li>A <code>discrete_distribution</code> has uniform-width intervals with uniform probability in each
    interval.</li>

    <li>A <code><a href="#piecewise_constant_distribution">piecewise_constant_distribution</a></code> has
    varying-width intervals with uniform probability in each interval.</li>

    <li>A <code><a href="#piecewise_linear_distribution">piecewise_linear_distribution</a></code> has
    varying-width intervals with linearly varying probability over each interval.</li>
  </ul>

  <h3><code><a name="discrete_distribution::discrete_distribution" id=
  "discrete_distribution::discrete_distribution">discrete_distribution::discrete_distribution</a></code></h3>
  <pre>
<b>discrete_distribution</b>();
<b>discrete_distribution</b>(initializer_list&lt;double&gt; init);
template&lt;class Fn&gt;
    <b>discrete_distribution</b>(size_t count,
        double low, double high, Fn func);
explicit <b>discrete_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> All elements in <code>init</code> are nonnegative
  and at least one is nonzero.</p>

  <p>The first constructor constructs an object whose stored value <code>stored_p</code> has one element with
  value 1.</p>

  <p>The second constructor constructs an object whose stored value <code>stored_p</code> is initialized with
  the sequence <code>[init.begin(), init.end())</code>, then normalized so that the sum of all elements is 1.
  If the sequence is empty, <code>stored_p</code> has one element with value 1.</p>

  <p>The third constructor constructs an object whose stored value <code>stored_p</code> is initialized with
  <code>count</code> elements. It divides the range <code>high - low</code> into <code>count</code> uniform
  subranges, then stores in element <code>I</code> the value <code>func(x)</code> for <code>x</code> in the
  middle of subrange <code>I</code>. If <code>count &lt; 1</code>, <code>stored_p</code> has one element with
  value 1.</p>

  <p>The fourth constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="discrete_distribution::max" id=
  "discrete_distribution::max">discrete_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="discrete_distribution::min" id=
  "discrete_distribution::min">discrete_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="discrete_distribution::operator()">discrete_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns integral values with each value
  <code>i</code> in the range <code>[0, stored_p.size() - 1)</code> occurring with probability
  <code>stored_p[i]</code> and all other values of <code>i</code> occurring with probability zero.</p>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="discrete_distribution::param" id=
  "discrete_distribution::param">discrete_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="discrete_distribution::param_type" id=
  "discrete_distribution::param_type">discrete_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef discrete_distribution&lt;IntType&gt; distribution_type;

    param_type();
    param_type(initializer_list&lt;double&gt; init);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);
    std::vector&lt;double&gt; probabilities() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="discrete_distribution::probabilities" id=
  "discrete_distribution::probabilities">discrete_distribution::probabilities</a></code></h3>
  <pre>
std::vector&lt;double&gt; <b>probabilities</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_p</code>.</p>

  <h3><code><a name="discrete_distribution::reset" id=
  "discrete_distribution::reset">discrete_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="discrete_distribution::result_type" id=
  "discrete_distribution::result_type">discrete_distribution::result_type</a></code></h3>
  <pre>
typedef IntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h2><code><a name="exponential_distribution" id=
  "exponential_distribution">exponential_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>exponential_distribution</b> {
public:
    typedef RealType <b><a href=
"#exponential_distribution::input_type">input_type</a></b>; <b>[removed with C++0X]</b>
    typedef RealType <b><a href="#exponential_distribution::result_type">result_type</a></b>;
    struct <b><a href="#exponential_distribution::param_type">param_type</a></b>; <b>[added with C++0X]</b>

    explicit <b><a href=
"#exponential_distribution::exponential_distribution">exponential_distribution</a></b>(result_type lambda0 = result_type(1.0));
    explicit <b><a href=
"#exponential_distribution::exponential_distribution">exponential_distribution</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#exponential_distribution::lambda">lambda</a></b>() const;
    param_type <b><a href="#exponential_distribution::param">param</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href=
"#exponential_distribution::param">param</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#exponential_distribution::min">min</a></b>() const; <b>[added with C++0X]</b>
    result_type <b><a href="#exponential_distribution::max">max</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href="#exponential_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#exponential_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#exponential_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0); <b>[added with C++0X]</b>

private:
    result_type <b>stored_lambda</b>;   <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type with an exponential distribution.</p>

  <h3><code><a name="exponential_distribution::exponential_distribution" id=
  "exponential_distribution::exponential_distribution">exponential_distribution::exponential_distribution</a></code></h3>
  <pre>
<b>exponential_distribution</b>(result_type lambda0 = result_type(1.0));
explicit <b>exponential_distribution</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; lambda0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_lambda</code> holds the value
  <code>lambda0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="exponential_distribution::input_type" id=
  "exponential_distribution::input_type">exponential_distribution::input_type</a></code></h3>
  <pre>
typedef RealType <b>input_type</b>; <b>[removed with C++0X]</b>
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="exponential_distribution::lambda" id=
  "exponential_distribution::lambda">exponential_distribution::lambda</a></code></h3>
  <pre>
result_type <b>lambda</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_lambda</code>.</p>

  <h3><code><a name="exponential_distribution::max" id=
  "exponential_distribution::max">exponential_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="exponential_distribution::min" id=
  "exponential_distribution::min">exponential_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name=
  "exponential_distribution::operator()">exponential_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="exponential_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="exponential_distribution::param" id=
  "exponential_distribution::param">exponential_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const; <b>[added with C++0X]</b>
void <b>param</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="exponential_distribution::param_type" id=
  "exponential_distribution::param_type">exponential_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> { <b>[added with C++0X]</b>
    typedef exponential_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type lambda0 = result_type(1.0));
    result_type lambda() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="exponential_distribution::reset" id=
  "exponential_distribution::reset">exponential_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="exponential_distribution::result_type" id=
  "exponential_distribution::result_type">exponential_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h2><code><a name="extreme_value_distribution" id=
  "extreme_value_distribution">extreme_value_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>extreme_value_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#extreme_value_distribution::result_type">result_type</a></b>;
    struct <b><a href="#extreme_value_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#extreme_value_distribution::extreme_value_distribution">extreme_value_distribution</a></b>(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    explicit <b><a href=
"#extreme_value_distribution::extreme_value_distribution">extreme_value_distribution</a></b>(const param_type&amp; par0);

    result_type <b><a href="#extreme_value_distribution::a">a</a></b>() const;
    result_type <b><a href="#extreme_value_distribution::b">b</a></b>() const;
    param_type <b><a href="#extreme_value_distribution::param">param</a></b>() const;
    void <b><a href="#extreme_value_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#extreme_value_distribution::min">min</a></b>() const;
    result_type <b><a href="#extreme_value_distribution::max">max</a></b>() const;
    void <b><a href="#extreme_value_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#extreme_value_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#extreme_value_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <b>stored_a</b>;  <i>// exposition only</i>
    result_type <b>stored_b</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed with an extreme-value (a.k.a. Gumbel Type I, log
  Weibull, or Fisher-Tippett Type I) distribution.</p>

  <h3><code><a name="extreme_value_distribution::a" id=
  "extreme_value_distribution::a">extreme_value_distribution::a</a></code></h3>
  <pre>
result_type <b>a</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_a</code>.</p>

  <h3><code><a name="extreme_value_distribution::b" id=
  "extreme_value_distribution::b">extreme_value_distribution::b</a></code></h3>
  <pre>
result_type <b>b</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_b</code>.</p>

  <h3><code><a name="extreme_value_distribution::extreme_value_distribution" id=
  "extreme_value_distribution::extreme_value_distribution">extreme_value_distribution::extreme_value_distribution</a></code></h3>
  <pre>
<b>extreme_value_distribution</b>(result_type a0 = result_type(0.0),
    result_type b0 = result_type(1.0));
explicit <b>extreme_value_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; b0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_a</code> holds the value
  <code>a0</code> and whose stored value <code>stored_b</code> holds the value <code>b0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="extreme_value_distribution::max" id=
  "extreme_value_distribution::max">extreme_value_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="extreme_value_distribution::min" id=
  "extreme_value_distribution::min">extreme_value_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name=
  "extreme_value_distribution::operator()">extreme_value_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="extreme_value_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="extreme_value_distribution::param" id=
  "extreme_value_distribution::param">extreme_value_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="extreme_value_distribution::param_type" id=
  "extreme_value_distribution::param_type">extreme_value_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef extreme_value_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="extreme_value_distribution::reset" id=
  "extreme_value_distribution::reset">extreme_value_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="extreme_value_distribution::result_type" id=
  "extreme_value_distribution::result_type">extreme_value_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h2><code><a name="fisher_f_distribution" id="fisher_f_distribution">fisher_f_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>fisher_f_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#fisher_f_distribution::result_type">result_type</a></b>;
    struct <b><a href="#fisher_f_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#fisher_f_distribution::fisher_f_distribution">fisher_f_distribution</a></b>(RealType m0 = 1,
        RealType n0 = 1);
    explicit <b><a href=
"#fisher_f_distribution::fisher_f_distribution">fisher_f_distribution</a></b>(const param_type&amp; par0);

    RealType <b><a href="#fisher_f_distribution::m">m</a></b>() const;
    RealType <b><a href="#fisher_f_distribution::n">n</a></b>() const;
    param_type <b><a href="#fisher_f_distribution::param">param</a></b>() const;
    void <b><a href="#fisher_f_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#fisher_f_distribution::min">min</a></b>() const;
    result_type <b><a href="#fisher_f_distribution::max">max</a></b>() const;
    void <b><a href="#fisher_f_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#fisher_f_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#fisher_f_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <b>stored_m</b>;  <i>// exposition only</i>
    RealType <b>stored_n</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed with a Fisher F distribution.</p>

  <h3><code><a name="fisher_f_distribution::fisher_f_distribution" id=
  "fisher_f_distribution::fisher_f_distribution">fisher_f_distribution::fisher_f_distribution</a></code></h3>
  <pre>
<b>fisher_f_distribution</b>(RealType m0 = 1,
    RealType n0 = 1);
explicit <b>fisher_f_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; m0 &amp;&amp; 0.0 &lt;
  n0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_m</code> holds the value
  <code>m0</code> and whose stored value <code>stored_n</code> holds the value <code>n0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="fisher_f_distribution::m" id=
  "fisher_f_distribution::m">fisher_f_distribution::m</a></code></h3>
  <pre>
RealType <b>m</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_m</code>.</p>

  <h3><code><a name="fisher_f_distribution::max" id=
  "fisher_f_distribution::max">fisher_f_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="fisher_f_distribution::min" id=
  "fisher_f_distribution::min">fisher_f_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="fisher_f_distribution::n" id=
  "fisher_f_distribution::n">fisher_f_distribution::n</a></code></h3>
  <pre>
RealType <b>n</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_n</code>.</p>

  <h3><code><a name="fisher_f_distribution::operator()">fisher_f_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="fisher_f_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="fisher_f_distribution::param" id=
  "fisher_f_distribution::param">fisher_f_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="fisher_f_distribution::param_type" id=
  "fisher_f_distribution::param_type">fisher_f_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef fisher_f_distribution&lt;RealType&gt; distribution_type;

    param_type(RealType m0 = 1, RealType n0 = 1);
    RealType m() const;
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="fisher_f_distribution::reset" id=
  "fisher_f_distribution::reset">fisher_f_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="fisher_f_distribution::result_type" id=
  "fisher_f_distribution::result_type">fisher_f_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h2><code><a name="gamma_distribution" id="gamma_distribution">gamma_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>gamma_distribution</b> {
public:
    typedef T1 <b><a href="#gamma_distribution::input_type">input_type</a></b>; <b>[removed with C++0X]</b>
    typedef RealType <b><a href="#gamma_distribution::result_type">result_type</a></b>;
    struct <b><a href="#gamma_distribution::param_type">param_type</a></b>; <b>[added with C++0X]</b>

    explicit <b><a href=
"#gamma_distribution::gamma_distribution">gamma_distribution</a></b>(result_type alpha0 = result_type(1.0),
        result_type beta0 = result_type(1.0)); <b>[beta added with C++0X]</b>
    explicit <b><a href=
"#gamma_distribution::gamma_distribution">gamma_distribution</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#gamma_distribution::alpha">alpha</a></b>() const;
    result_type <b><a href="#gamma_distribution::beta">beta</a></b>() const; <b>[added with C++0X]</b>
    param_type <b><a href="#gamma_distribution::param">param</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href=
"#gamma_distribution::param">param</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#gamma_distribution::min">min</a></b>() const; <b>[added with C++0X]</b>
    result_type <b><a href="#gamma_distribution::max">max</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href="#gamma_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#gamma_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#gamma_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0); <b>[added with C++0X]</b>

private:
    result_type <b>stored_alpha</b>;    <i>// exposition only</i>
    result_type <b>stored_beta</b>;     <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type with a gamma distribution.</p>

  <h3><code><a name="gamma_distribution::alpha" id=
  "gamma_distribution::alpha">gamma_distribution::alpha</a></code></h3>
  <pre>
result_type <b>alpha</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_alpha</code>.</p>

  <h3><code><a name="gamma_distribution::beta" id=
  "gamma_distribution::beta">gamma_distribution::beta</a></code></h3>
  <pre>
result_type <b>beta</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the stored value <code>stored_beta</code>.</p>

  <h3><code><a name="gamma_distribution::gamma_distribution" id=
  "gamma_distribution::gamma_distribution">gamma_distribution::gamma_distribution</a></code></h3>
  <pre>
<b>gamma_distribution</b>(result_type alpha0 = result_type(1.0));
    result_type beta0 = result_type(1.0)); <b>[beta added with C++0X]</b>
explicit <b>gamma_distribution</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; alpha0 &amp;&amp;0.0 &lt;
  beta0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_alpha</code> holds the value
  <code>alpha0</code> and whose stored value <code>stored_beta</code> holds the value <code>beta0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="gamma_distribution::input_type" id=
  "gamma_distribution::input_type">gamma_distribution::input_type</a></code></h3>
  <pre>
typedef T1 <b>input_type</b>; <b>[removed with C++0X]</b>
</pre>

  <p>The type is a synonym for the implementation-defined type <code>T1</code>.</p>

  <h3><code><a name="gamma_distribution::max" id=
  "gamma_distribution::max">gamma_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="gamma_distribution::min" id=
  "gamma_distribution::min">gamma_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="gamma_distribution::operator()">gamma_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="gamma_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="gamma_distribution::param" id=
  "gamma_distribution::param">gamma_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const; <b>[added with C++0X]</b>
void <b>param</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="gamma_distribution::param_type" id=
  "gamma_distribution::param_type">gamma_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> { <b>[added with C++0X]</b>
    typedef gamma_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type alpha0 = result_type(1.0),
        RealType beta0 result_type(1.0));
    RealType alpha() const;
    RealType beta() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="gamma_distribution::reset" id=
  "gamma_distribution::reset">gamma_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="gamma_distribution::result_type" id=
  "gamma_distribution::result_type">gamma_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h2><code><a name="generate_canonical" id="generate_canonical">generate_canonical</a></code></h2>
  <pre>
template&lt;class RealType,
    size_t bits,
    class Engine&gt;
    RealType <b>generate_canonical</b>(Engine&amp; gen); <b>[added with C++0X]</b>
</pre>

  <p>The template function calls <code>gen()</code> repeatedly and packs the returned values into a
  floating-point value <code>x</code> of type <code>RealType</code> until it has gathered the specified
  number of mantissa bits in <code>x</code>. The specified number is the smaller of <code>bits</code> (which
  must be nonzero) and the full number of mantissa bits in <code>RealType</code>. The first call supplies the
  lowest-order bits. The function returns <code>x</code>.</p>

  <h2><code><a name="geometric_distribution" id=
  "geometric_distribution">geometric_distribution</a></code></h2>
  <pre>
template&lt;class IntType = int,
    class RealType = double&gt; <b>[always double with C++0X]</b>
    class <b>geometric_distribution</b> {
public:
    typedef T1 <b><a href=
"#geometric_distribution::input_type">input_type</a></b>; <b>[removed with C++0X]</b>
    typedef IntType <b><a href="#geometric_distribution::result_type">result_type</a></b>;
    struct <b><a href="#geometric_distribution::param_type">param_type</a></b>; <b>[added with C++0X]</b>

    explicit <b><a href=
"#geometric_distribution::geometric_distribution">geometric_distribution</a></b>(RealType p0 = RealType(0.5));
    explicit <b><a href=
"#geometric_distribution::geometric_distribution">geometric_distribution</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    RealType <b><a href="#geometric_distribution::p">p</a></b>() const;
    param_type <b><a href="#geometric_distribution::param">param</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href=
"#geometric_distribution::param">param</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    void <b><a href="#geometric_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#geometric_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#geometric_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0); <b>[added with C++0X]</b>

private:
    RealType <b>stored_p</b>;          <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified integral type with a geometric distribution.</p>

  <h3><code><a name="geometric_distribution::geometric_distribution" id=
  "geometric_distribution::geometric_distribution">geometric_distribution::geometric_distribution</a></code></h3>
  <pre>
<b>geometric_distribution</b>(RealType p0 = RealType(0.5));
explicit <b>geometric_distribution</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; p0 &amp;&amp; p0 &lt;
  1.0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_p</code> holds the value
  <code>p0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="geometric_distribution::input_type" id=
  "geometric_distribution::input_type">geometric_distribution::input_type</a></code></h3>
  <pre>
typedef T1 <b>input_type</b>;
</pre>

  <p>The type is a synonym for the implementation-defined type <code>T1</code>.</p>

  <h3><code><a name="geometric_distribution::operator()">geometric_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed integral values and returns integral values with each value <code>i</code>
  occurring with probability:</p>
  <pre>
    <img src="geometric_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="geometric_distribution::p" id=
  "geometric_distribution::p">geometric_distribution::p</a></code></h3>
  <pre>
RealType <b>p</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_p</code>.</p>

  <h3><code><a name="geometric_distribution::param" id=
  "geometric_distribution::param">geometric_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const; <b>[added with C++0X]</b>
void <b>param</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="geometric_distribution::param_type" id=
  "geometric_distribution::param_type">geometric_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> { <b>[added with C++0X]</b>
    typedef binomial_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(RealType p0 = RealType(0.5));
    RealType p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="geometric_distribution::reset" id=
  "geometric_distribution::reset">geometric_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="geometric_distribution::result_type" id=
  "geometric_distribution::result_type">geometric_distribution::result_type</a></code></h3>
  <pre>
typedef IntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h2><code><a name="independent_bits_engine" id=
  "independent_bits_engine">independent_bits_engine</a></code></h2>
  <pre>
template&lt;class Engine,
    size_t W, class UIntType&gt;
    class <b>independent_bits_engine</b> { <b>[added with C++0X]</b>
public:
    typedef Engine <b><a href="#independent_bits_engine::base_type">base_type</a></b>;
    typedef typename base_type::result_type <b><a href=
"#independent_bits_engine::result_type">result_type</a></b>;

    <b><a href="#independent_bits_engine::independent_bits_engine">independent_bits_engine</a></b>();
    explicit <b><a href=
"#independent_bits_engine::independent_bits_engine">independent_bits_engine</a></b>(const base_type&amp; eng);
    explicit <b><a href=
"#independent_bits_engine::independent_bits_engine">independent_bits_engine</a></b>(result_type x0);
    explicit <b><a href=
"#independent_bits_engine::independent_bits_engine">independent_bits_engine</a></b>(seed_seq&amp; seq);
    void <b><a href="#independent_bits_engine::seed">seed</a></b>();
    void <b><a href="#independent_bits_engine::seed">seed</a></b>(result_type x0);
    void <b><a href="#independent_bits_engine::seed">seed</a></b>(seed_seq&amp; seq);

    const base_type&amp; <b><a href="#independent_bits_engine::base">base</a></b>() const;
    static constexpr result_type <b><a href="#independent_bits_engine::min">min</a></b>();
    static constexpr result_type <b><a href="#independent_bits_engine::max">max</a></b>();
    result_type <b><a href="#independent_bits_engine::operator()">operator()</a></b>();
    void <b><a href="#independent_bits_engine::discard">discard</a></b>(unsigned long long count);

private:
    Engine <b>stored_eng</b>;       <i>// exposition only</i>
    int <b>count</b>;               <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#compound%20engine">compound engine</a> that
  produces values by repacking bits as needed from the values returned by its base engine. Each resulting
  <code>W</code>-bit value consists of <code>N</code> fields combined as follows:</p>

  <ul>
    <li>The first <code>N0</code> fields consist of the low-order <code>W0</code> bits of values returned by
    the base engine that are less than <code>Y0</code>, packed in descending order of significance. Values
    that are too large are discarded.</li>

    <li>The remaining <code>N - N0</code> fields consist of the low-order <code>W0 + 1</code> bits of values
    returned by the base engine that are less than <code>Y1</code>, packed in descending order of
    significance. Values that are too large are discarded.</li>
  </ul>

  <p>The parameters above (other than <code>W</code>) are determined as follows:</p>

  <ul>
    <li><code>R</code> is the full range of values returned by the base engine (<code>stored_eng.max() -
    stored_eng.min() + 1</code>, assuming no wraparound occurs.)</li>

    <li><code>M</code> is <code>floor(log2(R))</code>.</li>

    <li><code>N</code> is initially <code>W / M + (W % M != 0)</code>.</li>

    <li><code>W0</code> is <code>W / N</code>.</li>

    <li><code>N0</code> is <code>N - W % N</code>.</li>

    <li><code>Y0</code> is <code>(R &gt;&gt; W0) &lt;&lt; W0</code>.</li>

    <li><code>Y1</code> is <code>(R &gt;&gt; W0 + 1) &lt;&lt; W0 + 1</code>.</li>

    <li>If <code>Y0 / N &lt; R - Y0</code> then <code>N</code> is incremented and the previous four
    parameters are redetermined.</li>
  </ul>

  <p>The engine's <a href="lib_rand.html#state">state</a> is the state of <code>stored_eng</code>. The value
  of the template argument <code>W</code> must be greater than zero and not greater than the number of bits
  representable in <code>result_type</code>.</p>

  <h3><code><a name="independent_bits_engine::base" id=
  "independent_bits_engine::base">independent_bits_engine::base</a></code></h3>
  <pre>
const base_type&amp; <b>base</b>() const;
</pre>

  <p>The member function returns a reference to the underlying engine object.</p>

  <h3><code><a name="independent_bits_engine::base_type" id=
  "independent_bits_engine::base_type">independent_bits_engine::base_type</a></code></h3>
  <pre>
typedef Engine <b>base_type</b>;
</pre>

  <p>The type is a synonym for the type of the underlying engine object.</p>

  <h3><code><a name="independent_bits_engine::discard" id=
  "independent_bits_engine::discard">independent_bits_engine::discard</a></code></h3>
  <pre>
void <b>discard</b>(unsigned long long count);
</pre>

  <p>The member function effectively calls <code>(*this)()</code> <code>count</code> times.</p>

  <h3><code><a name="independent_bits_engine::independent_bits_engine" id=
  "independent_bits_engine::independent_bits_engine">independent_bits_engine::independent_bits_engine</a></code></h3>
  <pre>
<b>independent_bits_engine</b>();
explicit <b>independent_bits_engine</b>(const base_type&amp; eng);
explicit <b>independent_bits_engine</b>(result_type x0);
explicit <b>independent_bits_engine</b>(seed_seq&amp; seq);
</pre>

  <p>The first constructor constructs a <code>independent_bits_engine</code> object with a
  default-initialized engine. The second contructor constructs a <code>independent_bits_engine</code> object
  with a copy of an engine object. The third constructor constucts a <code>independent_bits_engine</code>
  object with its engine initialized by <code>stored_engine(x0)</code>. The fourth constructor constucts a
  <code>independent_bits_engine</code> object with its engine initialized by
  <code>stored_engine(seq)</code>.</p>

  <h3><code><a name="independent_bits_engine::max" id=
  "independent_bits_engine::max">independent_bits_engine::max</a></code></h3>
  <pre>
static constexpr result_type <b>max</b>();
</pre>

  <p>The static member function returns <code>Engine::max()</code>.</p>

  <h3><code><a name="independent_bits_engine::min" id=
  "independent_bits_engine::min">independent_bits_engine::min</a></code></h3>
  <pre>
static constexpr result_type <b>min</b>();
</pre>

  <p>The static member function returns <code>Engine::min()</code>.</p>

  <h3><code><a name="independent_bits_engine::operator()">independent_bits_engine::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function returns the next value in the sequence.</p>

  <h3><code><a name="independent_bits_engine::result_type" id=
  "independent_bits_engine::result_type">independent_bits_engine::result_type</a></code></h3>
  <pre>
typedef typename base_type::result_type <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>base_type::result_type</code>.</p>

  <h3><code><a name="independent_bits_engine::seed" id=
  "independent_bits_engine::seed">independent_bits_engine::seed</a></code></h3>
  <pre>
void <b>seed</b>();
void <b>seed</b>(result_type x0);
void <b>seed</b>(seed_seq&amp; seq);
</pre>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> calls
  <code>stored_eng.seed()</code>. The second seed function calls <code>stored_eng.seed(x0)</code>. The second
  seed function calls <code>stored_eng.seed(seq)</code>.</p>

  <h2><code><a name="knuth_b" id="knuth_b">knuth_b</a></code></h2>
  <pre>
typedef shuffle_order_engine&lt;minstd_rand0, 256&gt;
    <b>knuth_b</b>; <b>[added with C++0X]</b>
</pre>

  <p>The type is a synonym for a specialization of the template <code>shuffle_order_engine</code> with a
  specialization of the template <code>linear_congruential</code>.</p>

  <h2><code><a name="linear_congruential" id="linear_congruential">linear_congruential</a></code></h2>
  <pre>
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <b>linear_congruential</b> {
public:
    typedef UIntType <b><a href="#linear_congruential::result_type">result_type</a></b>;
    static constexpr UIntType <b><a href="#linear_congruential::multiplier">multiplier</a></b> = A;
    static constexpr UIntType <b><a href="#linear_congruential::increment">increment</a></b> = C;
    static constexpr UIntType <b><a href="#linear_congruential::modulus">modulus</a></b> = M;

    <b><a href="#linear_congruential::linear_congruential">linear_congruential</a></b>();
    explicit <b><a href=
"#linear_congruential::linear_congruential">linear_congruential</a></b>(unsigned long x0);
    template&lt;class Gen&gt;
        <b><a href="#linear_congruential::linear_congruential">linear_congruential</a></b>(Gen&amp; gen);
    void <b><a href="#linear_congruential::seed">seed</a></b>(unsigned long x0 = 1);
    template&lt;class Gen&gt;
        void <b><a href="#linear_congruential::seed">seed</a></b>(Gen&amp; gen);

    result_type <b><a href="#linear_congruential::min">min</a></b>() const;
    result_type <b><a href="#linear_congruential::max">max</a></b>() const;
    result_type <b><a href="#linear_congruential::operator()">operator()</a></b>();

private:
    result_type <b>stored_value</b>;    <i>// exposition only</i>
    };
</pre>

  <p>The template class describes a <a href="lib_rand.html#simple%20engine">simple engine</a> that produces
  values of a user-specified unsigned integral type using the <b><a name=
  "linear_congruential::recurrence relation">recurrence relation</a></b> <code>x(i) = (A * x(i-1) + C) mod
  M</code>. The engine's <a href="lib_rand.html#state">state</a> is the last value returned, or the seed
  value if no call has been made to <code>operator()</code>.</p>

  <p>The template argument <a href="lib_rand.html#UIntType">UIntType</a> must be large enough to hold values
  up to <code>M - 1</code>. The values of the template arguments <code>A</code> and <code>C</code> must be
  less than <code>M</code>.</p>

  <h3><code><a name="linear_congruential::increment" id=
  "linear_congruential::increment">linear_congruential::increment</a></code></h3>
  <pre>
static constexpr UIntType <b>increment</b> = C;
</pre>

  <p>The static const variable holds the value of the template argument <code>C</code>.</p>

  <h3><code><a name="linear_congruential::linear_congruential" id=
  "linear_congruential::linear_congruential">linear_congruential::linear_congruential</a></code></h3>
  <pre>
<b>linear_congruential</b>();
explicit <b>linear_congruential</b>(unsigned long x0);
template&lt;class Gen&gt;
    <b>linear_congruential</b>(Gen&amp; gen);
</pre>

  <p>The first constructor constructs an object and initializes it by calling <code>seed()</code>. The second
  constructor constructs an object and initializes it by calling <code>seed(x0)</code>. The third constructor
  constructs an object and initializes it by calling <code>seed(gen)</code>.</p>

  <h3><code><a name="linear_congruential::max" id=
  "linear_congruential::max">linear_congruential::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns <code>M - 1</code>.</p>

  <h3><code><a name="linear_congruential::min" id=
  "linear_congruential::min">linear_congruential::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns <code>C == 0 ? 1 : 0</code>.</p>

  <h3><code><a name="linear_congruential::modulus" id=
  "linear_congruential::modulus">linear_congruential::modulus</a></code></h3>
  <pre>
static constexpr UIntType <b>modulus</b> = M;
</pre>

  <p>The static const variable holds the value of the template argument <code>M</code>.</p>

  <h3><code><a name="linear_congruential::multiplier" id=
  "linear_congruential::multiplier">linear_congruential::multiplier</a></code></h3>
  <pre>
static constexpr UIntType <b>multiplier</b> = A;
</pre>

  <p>The static const variable holds the value of template argument <code>A</code>.</p>

  <h3><code><a name="linear_congruential::operator()">linear_congruential::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function generates a new <code>stored_value</code> by applying the <a href=
  "#linear_congruential::recurrence%20relation">recurrence relation</a> to the old value of
  <code>stored_value</code>.</p>

  <h3><code><a name="linear_congruential::result_type" id=
  "linear_congruential::result_type">linear_congruential::result_type</a></code></h3>
  <pre>
typedef UIntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>UIntType</code>.</p>

  <h3><code><a name="linear_congruential::seed" id=
  "linear_congruential::seed">linear_congruential::seed</a></code></h3>
  <pre>
void <b>seed</b>(unsigned long x0 = 1);
template&lt;class Gen&gt;
    void <b>seed</b>(Gen&amp; gen);
</pre>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> sets the stored value
  <code>stored_value</code> to 1 if <code>C mod M == 0</code> and <code>x0 mod M == 0</code>, otherwise it
  sets the stored value to <code>x0 mod M</code>. The second seed function calls
  <code>seed(gen())</code>.</p>

  <h2><code><a name="linear_congruential_engine" id=
  "linear_congruential_engine">linear_congruential_engine</a></code></h2>
  <pre>
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    class <b>linear_congruential_engine</b> { <b>[added with C++0X]</b>
public:
    typedef UIntType <b><a href="#linear_congruential_engine::result_type">result_type</a></b>;
    static constexpr UIntType <b><a href="#linear_congruential_engine::multiplier">multiplier</a></b> = A;
    static constexpr UIntType <b><a href="#linear_congruential_engine::increment">increment</a></b> = C;
    static constexpr UIntType <b><a href="#linear_congruential_engine::modulus">modulus</a></b> = M;
    static constexpr UIntType <b><a href=
"#linear_congruential_engine::default_seed">default_seed</a></b> = 1U;

    explicit <b><a href=
"#linear_congruential_engine::linear_congruential_engine">linear_congruential_engine</a></b>(result_type x0 = default_seed);
    explicit <b><a href=
"#linear_congruential_engine::linear_congruential_engine">linear_congruential_engine</a></b>(seed_seq&amp; seq);
    void <b><a href="#linear_congruential_engine::seed">seed</a></b>(result_type x0 = default_seed);
    void <b><a href="#linear_congruential_engine::seed">seed</a></b>(seed_seq&amp; seq);

    static constexpr result_type <b><a href="#linear_congruential_engine::min">min</a></b>();
    static constexpr result_type <b><a href="#linear_congruential_engine::max">max</a></b>();
    result_type <b><a href="#linear_congruential_engine::operator()">operator()</a></b>();
    void <b><a href="#linear_congruential_engine::discard">discard</a></b>(unsigned long long count)();

private:
    result_type <b>stored_value</b>;    <i>// exposition only</i>
    };
</pre>

  <p>The template class describes a <a href="lib_rand.html#simple%20engine">simple engine</a> that produces
  values of a user-specified unsigned integral type using the <b><a name=
  "linear_congruential_engine::recurrence relation">recurrence relation</a></b> <code>x(i) = (A * x(i-1) + C)
  mod M</code>. The engine's <a href="lib_rand.html#state">state</a> is the last value returned, or the seed
  value if no call has been made to <code>operator()</code>.</p>

  <p>The template argument <a href="lib_rand.html#UIntType">UIntType</a> must be large enough to hold values
  up to <code>M - 1</code>. The values of the template arguments <code>A</code> and <code>C</code> must be
  less than <code>M</code>.</p>

  <h3><code><a name="linear_congruential_engine::default_seed" id=
  "linear_congruential_engine::default_seed">linear_congruential_engine::default_seed</a></code></h3>
  <pre>
static constexpr UIntType <b>default_seed</b> = 1U;
</pre>

  <p>The static const variable holds the default seed value <code>1U</code>.</p>

  <h3><code><a name="linear_congruential_engine::discard" id=
  "linear_congruential_engine::discard">linear_congruential_engine::discard</a></code></h3>
  <pre>
void <b>discard</b>(unsigned long long count);
</pre>

  <p>The member function effectively calls <code>(*this)()</code> <code>count</code> times.</p>

  <h3><code><a name="linear_congruential_engine::increment" id=
  "linear_congruential_engine::increment">linear_congruential_engine::increment</a></code></h3>
  <pre>
static constexpr UIntType <b>increment</b> = C;
</pre>

  <p>The static const variable holds the value of the template argument <code>C</code>.</p>

  <h3><code><a name="linear_congruential_engine::linear_congruential_engine" id=
  "linear_congruential_engine::linear_congruential_engine">linear_congruential_engine::linear_congruential_engine</a></code></h3>
  <pre>
explicit <b>linear_congruential_engine</b>(result_type x0 = default_seed);
explicit <b>linear_congruential_engine</b>(seed_seq&amp; seq);
</pre>

  <p>The first constructor constructs an object and initializes it by calling <code>seed(x0)</code>. The
  second constructor constructs an object and initializes it by calling <code>seed(seq)</code>.</p>

  <h3><code><a name="linear_congruential_engine::max" id=
  "linear_congruential_engine::max">linear_congruential_engine::max</a></code></h3>
  <pre>
static constexpr result_type <b>max</b>();
</pre>

  <p>The static member function returns <code>M - 1</code>.</p>

  <h3><code><a name="linear_congruential_engine::min" id=
  "linear_congruential_engine::min">linear_congruential_engine::min</a></code></h3>
  <pre>
static constexpr result_type <b>min</b>() const;
</pre>

  <p>The static member function returns <code>C == 0 ? 1 : 0</code>.</p>

  <h3><code><a name="linear_congruential_engine::modulus" id=
  "linear_congruential_engine::modulus">linear_congruential_engine::modulus</a></code></h3>
  <pre>
static constexpr UIntType <b>modulus</b> = M;
</pre>

  <p>The static const variable holds the value of the template argument <code>M</code>.</p>

  <h3><code><a name="linear_congruential_engine::multiplier" id=
  "linear_congruential_engine::multiplier">linear_congruential_engine::multiplier</a></code></h3>
  <pre>
static constexpr UIntType <b>multiplier</b> = A;
</pre>

  <p>The static const variable holds the value of template argument <code>A</code>.</p>

  <h3><code><a name=
  "linear_congruential_engine::operator()">linear_congruential_engine::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function generates a new <code>stored_value</code> by applying the <a href=
  "#linear_congruential_engine::recurrence%20relation">recurrence relation</a> to the old value of
  <code>stored_value</code>.</p>

  <h3><code><a name="linear_congruential_engine::result_type" id=
  "linear_congruential_engine::result_type">linear_congruential_engine::result_type</a></code></h3>
  <pre>
typedef UIntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>UIntType</code>.</p>

  <h3><code><a name="linear_congruential_engine::seed" id=
  "linear_congruential_engine::seed">linear_congruential_engine::seed</a></code></h3>
  <pre>
void <b>seed</b>(result_type x0 = default_seed);
void <b>seed</b>(seed_seq&amp; seq);
</pre>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> sets the stored value
  <code>stored_value</code> to 1 if <code>C mod M == 0</code> and <code>x0 mod M == 0</code>, otherwise it
  sets the stored value to <code>x0 mod M</code>. The second seed function calls <code>seed(x)</code>, where
  <code>x</code> is determined as follows:</p>

  <ul>
    <li><code>k</code> is the number of <i>unsigned long</i> integers needed to supply all the bits in a
    <code>UIntType</code> integer (at least 1).</li>

    <li><code>a</code> is an array of <code>3 + k</code> elements of type <code>UIntType</code>.</li>

    <li><code>a</code> is initialized by calling <code>seq.generate(&amp;a[0], &amp;a[3 + k])</code>.</li>

    <li><code>x</code> is composed by packing the <code>k</code> elements beginning at <code>a[3]</code>,
    which supplies the lowest-order bits.</li>
  </ul>

  <h2><code><a name="lognormal_distribution" id=
  "lognormal_distribution">lognormal_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>lognormal_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#lognormal_distribution::result_type">result_type</a></b>;
    struct <b><a href="#lognormal_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#lognormal_distribution::lognormal_distribution">lognormal_distribution</a></b>(result_type m0 = result_type(0.0),
        result_type s0 = result_type(1.0));
    explicit <b><a href=
"#lognormal_distribution::lognormal_distribution">lognormal_distribution</a></b>(const param_type&amp; par0);

    result_type <b><a href="#lognormal_distribution::m">m</a></b>() const;
    result_type <b><a href="#lognormal_distribution::s">s</a></b>() const;
    param_type <b><a href="#lognormal_distribution::param">param</a></b>() const;
    void <b><a href="#lognormal_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#lognormal_distribution::min">min</a></b>() const;
    result_type <b><a href="#lognormal_distribution::max">max</a></b>() const;
    void <b><a href="#lognormal_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#lognormal_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#lognormal_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <b>stored_a</b>;  <i>// exposition only</i>
    result_type <b>stored_b</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed with a log normal distribution.</p>

  <h3><code><a name="lognormal_distribution::lognormal_distribution" id=
  "lognormal_distribution::lognormal_distribution">lognormal_distribution::lognormal_distribution</a></code></h3>
  <pre>
<b>lognormal_distribution</b>(result_type m0 = result_type(0.0),
    result_type s0 = result_type(1.0));
explicit <b>lognormal_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; s0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_m</code> holds the value
  <code>m0</code> and whose stored value <code>stored_s</code> holds the value <code>s0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="lognormal_distribution::m" id=
  "lognormal_distribution::m">lognormal_distribution::m</a></code></h3>
  <pre>
result_type <b>m</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_m</code>.</p>

  <h3><code><a name="lognormal_distribution::max" id=
  "lognormal_distribution::max">lognormal_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="lognormal_distribution::min" id=
  "lognormal_distribution::min">lognormal_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="lognormal_distribution::operator()">lognormal_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="lognormal_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="lognormal_distribution::param" id=
  "lognormal_distribution::param">lognormal_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="lognormal_distribution::param_type" id=
  "lognormal_distribution::param_type">lognormal_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef lognormal_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type m0 = result_type(0.0),
        result_type s0 = result_type(1.0));
    result_type m() const;
    result_type s() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="lognormal_distribution::reset" id=
  "lognormal_distribution::reset">lognormal_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="lognormal_distribution::result_type" id=
  "lognormal_distribution::result_type">lognormal_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="lognormal_distribution::s" id=
  "lognormal_distribution::s">lognormal_distribution::s</a></code></h3>
  <pre>
result_type <b>s</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_s</code>.</p>

  <h2><code><a name="mersenne_twister" id="mersenne_twister">mersenne_twister</a></code></h2>
  <pre>
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    class <b>mersenne_twister</b> {
public:
    typedef UIntType <b><a href="#mersenne_twister::result_type">result_type</a></b>;
    static constexpr int <b><a href="#mersenne_twister::word_size">word_size</a></b> = W;
    static constexpr int <b><a href="#mersenne_twister::state_size">state_size</a></b> = N;
    static constexpr int <b><a href="#mersenne_twister::shift_size">shift_size</a></b> = M;
    static constexpr int <b><a href="#mersenne_twister::mask_bits">mask_bits</a></b> = R;
    static constexpr UIntType <b><a href="#mersenne_twister::parameter_a">parameter_a</a></b> = A;
    static constexpr int <b><a href="#mersenne_twister::output_u">output_u</a></b> = U;
    static constexpr int <b><a href="#mersenne_twister::output_s">output_s</a></b> = S;
    static constexpr UIntType <b><a href="#mersenne_twister::output_b">output_b</a></b> = B;
    static constexpr int <b><a href="#mersenne_twister::output_t">output_t</a></b> = T;
    static constexpr UIntType <b><a href="#mersenne_twister::output_c">output_c</a></b> = C;
    static constexpr int <b><a href="#mersenne_twister::output_l">output_l</a></b> = L;

    <b><a href="#mersenne_twister::mersenne_twister">mersenne_twister</a></b>();
    explicit <b><a href="#mersenne_twister::mersenne_twister">mersenne_twister</a></b>(unsigned long x0);
    template&lt;class Gen&gt;
        <b><a href="#mersenne_twister::mersenne_twister">mersenne_twister</a></b>(Gen&amp; gen);
    void <b><a href="#mersenne_twister::seed">seed</a></b>();
    void <b><a href="#mersenne_twister::seed">seed</a></b>(unsigned long x0);
    template&lt;class Gen&gt;
        void <b><a href="#mersenne_twister::seed">seed</a></b>(Gen&amp; gen);

    result_type <b><a href="#mersenne_twister::min">min</a></b>() const;
    result_type <b><a href="#mersenne_twister::max">max</a></b>() const;
    result_type <b><a href="#mersenne_twister::operator()">operator()</a></b>();
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#simple%20engine">simple engine</a>. It holds a
  large integral value with <code>W * (N - 1) + R</code> bits. It extracts <code>W</code> bits at a time from
  this large value, and when it has used all the bits it twists the large value by shifting and mixing the
  bits so that it has a new set of bits to extract from. The engine's <a href="lib_rand.html#state">state</a>
  is the last <code>N</code> <code>W</code>-bit values used if <code>operator()</code> has been called at
  least <code>N</code> times, otherwise the <code>M</code> <code>W</code>-bit values that have been used and
  the last <code>N - M</code> values of the <a href="lib_rand.html#seed%20function">seed</a>.</p>

  <p>The template argument <a href="lib_rand.html#UIntType">UIntType</a> must be large enough to hold values
  up to <code>2<sup>W</sup> - 1</code>. The values of the other template arguments must satisfy the following
  requirements:</p>

  <ul>
    <li><code>1 &lt; M &lt;= N</code></li>

    <li><code>0 &lt;= R, U, S, T, L &lt;= W</code></li>

    <li><code>0 &lt;= A, B, C &lt;= 2<sup>W</sup> - 1</code></li>

    <li><code>W * (N - 1) + R</code> must be a Mersenne prime</li>
  </ul>

  <p>The generator <b><a name="mersenne_twister::twists" id="mersenne_twister::twists">twists</a></b> the
  large value that it holds by executing the following code:</p>
  <pre>
    for (int i = 0; i &lt; N; ++i)
        {    // twist
        temp = (x[i] &amp; LMASK) &lt;&lt; (W - 1) | (x[i + 1] &amp; HMASK) &gt;&gt; 1;
        if (temp &amp; 1)
            y[i] = (temp &gt;&gt; 1) ^ A ^ x[(i + R) % N];
        else
            y[i] = (temp &gt;&gt; 1) ^ x[(i + R) % N];
        }
        for (int i = 0; i &lt; N; ++i)
            x[i] = y[i];
</pre>

  <p>where <code>LMASK</code> is an unsigned <code>W</code>-bit value with its low <code>R</code> bits set to
  1 and the rest of its bits set to 0, and <code>HMASK</code> is the complement of <code>LMASK</code>.</p>

  <p>The generator holds a current index <code>idx</code> initialized to 0. It <a name=
  "mersenne_twister::extracts" id="mersenne_twister::extracts">extracts bits</a> by executing the following
  code:</p>
  <pre>
    temp = x[idx++];
    temp = temp ^ (temp &gt;&gt; U);
    temp = temp ^ ((temp &lt;&lt; S) &amp; B);
    temp = temp ^ ((temp &lt;&lt; T) &amp; C);
    temp = temp ^ (temp &gt;&gt; L);
</pre>

  <p>When <code>idx</code> reaches <code>N</code> the generator <a href=
  "#mersenne_twister::twists">twists</a> the stored value and sets <code>idx</code> back to 0.</p>

  <h3><code><a name="mersenne_twister::mask_bits" id=
  "mersenne_twister::mask_bits">mersenne_twister::mask_bits</a></code></h3>
  <pre>
static constexpr int <b>mask_bits</b> = R;
</pre>

  <p>The static const variable holds the value of the template argument <code>R</code>.</p>

  <h3><code><a name="mersenne_twister::max" id="mersenne_twister::max">mersenne_twister::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value in the generated sequence.</p>

  <h3><code><a name="mersenne_twister::mersenne_twister" id=
  "mersenne_twister::mersenne_twister">mersenne_twister::mersenne_twister</a></code></h3>
  <pre>
<b>mersenne_twister</b>();
explicit <b>mersenne_twister</b>(unsigned long x0);
template&lt;class Gen&gt;
    <b>mersenne_twister</b>(Gen&amp; gen);
</pre>

  <p>The first constructor constructs an object and initializes it by calling <code>seed()</code>. The second
  constructor constructs an object and initializes it by calling <code>seed(x0)</code>. The third constructor
  constructs an object and initializes it by calling <code>seed(gen)</code>.</p>

  <h3><code><a name="mersenne_twister::min" id="mersenne_twister::min">mersenne_twister::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns zero.</p>

  <h3><code><a name="mersenne_twister::operator()">mersenne_twister::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function <a href="#mersenne_twister::extracts">extracts</a> the next value in the sequence
  and returns it.</p>

  <h3><code><a name="mersenne_twister::output_b" id=
  "mersenne_twister::output_b">mersenne_twister::output_b</a></code></h3>
  <pre>
static constexpr UIntType <b>output_b</b> = B;
</pre>

  <p>The static const variable holds the value of the template argument <code>B</code>.</p>

  <h3><code><a name="mersenne_twister::output_c" id=
  "mersenne_twister::output_c">mersenne_twister::output_c</a></code></h3>
  <pre>
static constexpr UIntType <b>output_c</b> = C;
</pre>

  <p>The static const variable holds the value of the template argument <code>C</code>.</p>

  <h3><code><a name="mersenne_twister::output_l" id=
  "mersenne_twister::output_l">mersenne_twister::output_l</a></code></h3>
  <pre>
static constexpr int <b>output_l</b> = L;
</pre>

  <p>The static const variable holds the value of the template argument <code>L</code>.</p>

  <h3><code><a name="mersenne_twister::output_s" id=
  "mersenne_twister::output_s">mersenne_twister::output_s</a></code></h3>
  <pre>
static constexpr int <b>output_s</b> = S;
</pre>

  <p>The static const variable holds the value of the template argument <code>S</code>.</p>

  <h3><code><a name="mersenne_twister::output_t" id=
  "mersenne_twister::output_t">mersenne_twister::output_t</a></code></h3>
  <pre>
static constexpr int <b>output_t</b> = T;
</pre>

  <p>The static const variable holds the value of the template argument <code>T</code>.</p>

  <h3><code><a name="mersenne_twister::output_u" id=
  "mersenne_twister::output_u">mersenne_twister::output_u</a></code></h3>
  <pre>
static constexpr int <b>output_u</b> = U;
</pre>

  <p>The static const variable holds the value of the template argument <code>U</code>.</p>

  <h3><code><a name="mersenne_twister::parameter_a" id=
  "mersenne_twister::parameter_a">mersenne_twister::parameter_a</a></code></h3>
  <pre>
static constexpr UIntType <b>parameter_a</b> = A;
</pre>

  <p>The static const variable holds the value of the template argument <code>A</code>.</p>

  <h3><code><a name="mersenne_twister::result_type" id=
  "mersenne_twister::result_type">mersenne_twister::result_type</a></code></h3>
  <pre>
typedef UIntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>UIntType</code>.</p>

  <h3><code><a name="mersenne_twister::seed" id=
  "mersenne_twister::seed">mersenne_twister::seed</a></code></h3>
  <pre>
template&lt;class Gen&gt;
    void <b>seed</b>(Gen&amp; gen);
void <b>seed</b>();
void <b>seed</b>(unsigned long x0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0 &lt; x0</code></p>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> generates <code>N</code> values from
  the values of type <code>unsigned long</code> returned by successive invocations of <code>gen</code> and
  then <a href="#mersenne_twister::twists">twists</a> the resulting large integer value. Each value is
  <code>gen() % 2<sup>W</sup></code>.</p>

  <p>The second seed function calls <code>seed(4357)</code>.</p>

  <p>The third seed function sets the oldest historical value <code>h[0]</code> to <code>x0 mod
  2<sup>W</sup></code>, then iteratively sets each successive historical value <code>h[i]</code> to <code>(i
  + 1812433253 * (h[i - 1] &gt;&gt; (W - 2))) mod 2<sup>W</sup></code>, for <code>i</code> ranging from
  <code>1</code> to <code>N - 1</code>.</p>

  <h3><code><a name="mersenne_twister::shift_size" id=
  "mersenne_twister::shift_size">mersenne_twister::shift_size</a></code></h3>
  <pre>
static constexpr int <b>shift_size</b> = M;
</pre>

  <p>The static const variable holds the value of the template argument <code>M</code>.</p>

  <h3><code><a name="mersenne_twister::state_size" id=
  "mersenne_twister::state_size">mersenne_twister::state_size</a></code></h3>
  <pre>
static constexpr int <b>state_size</b> = N;
</pre>

  <p>The static const variable holds the value of the template argument <code>N</code>.</p>

  <h3><code><a name="mersenne_twister::word_size" id=
  "mersenne_twister::word_size">mersenne_twister::word_size</a></code></h3>
  <pre>
static constexpr int <b>word_size</b> = W;
</pre>

  <p>The static const variable holds the value of the template argument <code>W</code>.</p>

  <h2><code><a name="mersenne_twister_engine" id=
  "mersenne_twister_engine">mersenne_twister_engine</a></code></h2>
  <pre>
template&lt;class UIntType,
    size_t W, size_t N, size_t M, size_t R,
    UIntType A, size_t U,
    UIntType D, size_t S,
    UIntType B, size_t T,
    UIntType C, size_t L
    UIntType F&gt;
    class <b>mersenne_twister_engine</b> { <b>[added with C++0X]</b>
public:
    typedef UIntType <b><a href="#mersenne_twister_engine::result_type">result_type</a></b>;
    static constexpr size_t <b><a href="#mersenne_twister_engine::word_size">word_size</a></b> = W;
    static constexpr size_t <b><a href="#mersenne_twister_engine::state_size">state_size</a></b> = N;
    static constexpr size_t <b><a href="#mersenne_twister_engine::shift_size">shift_size</a></b> = M;
    static constexpr size_t <b><a href="#mersenne_twister_engine::mask_bits">mask_bits</a></b> = R;
    static constexpr UIntType <b><a href="#mersenne_twister_engine::xor_mask">xor_mask</a></b> = A;
    static constexpr size_t <b><a href="#mersenne_twister_engine::tempering_u">tempering_u</a></b> = U;
    static constexpr size_t <b><a href="#mersenne_twister_engine::tempering_d">tempering_d</a></b> = D;
    static constexpr size_t <b><a href="#mersenne_twister_engine::tempering_s">tempering_s</a></b> = S;
    static constexpr UIntType <b><a href="#mersenne_twister_engine::tempering_b">tempering_b</a></b> = B;
    static constexpr size_t <b><a href="#mersenne_twister_engine::tempering_t">tempering_t</a></b> = T;
    static constexpr UIntType <b><a href="#mersenne_twister_engine::tempering_c">tempering_c</a></b> = C;
    static constexpr size_t <b><a href="#mersenne_twister_engine::tempering_l">tempering_l</a></b> = L;
    static constexpr UIntType <b><a href=
"#mersenne_twister_engine::initialization_multiplier">initialization_multiplier</a></b> = C;
    static constexpr result_type <b><a href=
"#mersenne_twister_engine::default_seed">default_seed</a></b> = 5489U;

    explicit <b><a href=
"#mersenne_twister_engine::mersenne_twister_engine">mersenne_twister_engine</a></b>(unsigned long x0 = default_seed);
    explicit <b><a href=
"#mersenne_twister_engine::mersenne_twister_engine">mersenne_twister_engine</a></b>(seed_seq&amp; seq);
    void <b><a href="#mersenne_twister_engine::seed">seed</a></b>(unsigned long x0 = default_seed);
    template&lt;class Gen&gt;
        void <b><a href="#mersenne_twister_engine::seed">seed</a></b>(seed_seq&amp; seq);

    result_type <b><a href="#mersenne_twister_engine::min">min</a></b>() const;
    result_type <b><a href="#mersenne_twister_engine::max">max</a></b>() const;
    result_type <b><a href="#mersenne_twister_engine::operator()">operator()</a></b>();
    void <b><a href="#mersenne_twister_engine::discard">discard</a></b>(unsigned long long count)();
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#simple%20engine">simple engine</a>. It holds a
  large integral value with <code>W * (N - 1) + R</code> bits. It extracts <code>W</code> bits at a time from
  this large value, and when it has used all the bits it twists the large value by shifting and mixing the
  bits so that it has a new set of bits to extract from. The engine's <a href="lib_rand.html#state">state</a>
  is the last <code>N</code> <code>W</code>-bit values used if <code>operator()</code> has been called at
  least <code>N</code> times, otherwise the <code>M</code> <code>W</code>-bit values that have been used and
  the last <code>N - M</code> values of the <a href="lib_rand.html#seed%20function">seed</a>.</p>

  <p>The template argument <a href="lib_rand.html#UIntType">UIntType</a> must be large enough to hold values
  up to <code>2<sup>W</sup> - 1</code>. The values of the other template arguments must satisfy the following
  requirements:</p>

  <ul>
    <li><code>1 &lt; M &lt;= N</code></li>

    <li><code>0 &lt;= R, U, S, T, L &lt;= W</code></li>

    <li><code>0 &lt;= A, B, C &lt;= 2<sup>W</sup> - 1</code></li>

    <li><code>W * (N - 1) + R</code> must be a Mersenne prime</li>
  </ul>

  <p>The generator <b><a name="mersenne_twister_engine::twists" id=
  "mersenne_twister_engine::twists">twists</a></b> the large value that it holds by executing the following
  code:</p>
  <pre>
    for (size_t i = 0; i &lt; N; ++i)
        {    // twist
        temp = (x[i] &amp; LMASK) &lt;&lt; (W - 1) | (x[i + 1] &amp; HMASK) &gt;&gt; 1;
        if (temp &amp; 1)
            y[i] = (temp &gt;&gt; 1) ^ A ^ x[(i + R) % N];
        else
            y[i] = (temp &gt;&gt; 1) ^ x[(i + R) % N];
        }
        for (size_t i = 0; i &lt; N; ++i)
            x[i] = y[i];
</pre>

  <p>where <code>LMASK</code> is an unsigned <code>W</code>-bit value with its low <code>R</code> bits set to
  1 and the rest of its bits set to 0, and <code>HMASK</code> is the complement of <code>LMASK</code>.</p>

  <p>The generator holds a current index <code>idx</code> initialized to 0. It <a name=
  "mersenne_twister_engine::extracts" id="mersenne_twister_engine::extracts">extracts bits</a> by executing
  the following code:</p>
  <pre>
    temp = x[idx++];
    temp = temp ^ ((temp &gt;&gt; U) &amp; D);
    temp = temp ^ ((temp &lt;&lt; S) &amp; B);
    temp = temp ^ ((temp &lt;&lt; T) &amp; C);
    temp = temp ^ (temp &gt;&gt; L);
</pre>

  <p>When <code>idx</code> reaches <code>N</code> the generator <a href=
  "#mersenne_twister_engine::twists">twists</a> the stored value and sets <code>idx</code> back to 0.</p>

  <h3><code><a name="mersenne_twister_engine::default_seed" id=
  "mersenne_twister_engine::default_seed">mersenne_twister_engine::default_seed</a></code></h3>
  <pre>
static constexpr result_type <b>default_seed</b> = 5489U;
</pre>

  <p>The static const variable holds the default seed value <code>5489U</code>.</p>

  <h3><code><a name="mersenne_twister_engine::discard" id=
  "mersenne_twister_engine::discard">mersenne_twister_engine::discard</a></code></h3>
  <pre>
void <b>discard</b>(unsigned long long count);
</pre>

  <p>The member function effectively calls <code>(*this)()</code> <code>count</code> times.</p>

  <h3><code><a name="mersenne_twister_engine::initialization_multiplier" id=
  "mersenne_twister_engine::initialization_multiplier">mersenne_twister_engine::initialization_multiplier</a></code></h3>
  <pre>
static constexpr UIntType <b>initialization_multiplier</b> = F;
</pre>

  <p>The static const variable holds the value of the template argument <code>F</code>.</p>

  <h3><code><a name="mersenne_twister_engine::mask_bits" id=
  "mersenne_twister_engine::mask_bits">mersenne_twister_engine::mask_bits</a></code></h3>
  <pre>
static constexpr size_t <b>mask_bits</b> = R;
</pre>

  <p>The static const variable holds the value of the template argument <code>R</code>.</p>

  <h3><code><a name="mersenne_twister_engine::max" id=
  "mersenne_twister_engine::max">mersenne_twister_engine::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value in the generated sequence.</p>

  <h3><code><a name="mersenne_twister_engine::mersenne_twister_engine" id=
  "mersenne_twister_engine::mersenne_twister_engine">mersenne_twister_engine::mersenne_twister_engine</a></code></h3>
  <pre>
explicit <b>mersenne_twister_engine</b>(unsigned long x0 = default_seed);
<b>explicit mersenne_twister_engine</b>(default_seed&amp; seq);
</pre>

  <p>The first constructor constructs an object and initializes it by calling <code>seed(x0)</code>. The
  second constructor constructs an object and initializes it by calling <code>seed(seq)</code>.</p>

  <h3><code><a name="mersenne_twister_engine::min" id=
  "mersenne_twister_engine::min">mersenne_twister_engine::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns zero.</p>

  <h3><code><a name="mersenne_twister_engine::operator()">mersenne_twister_engine::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function <a href="#mersenne_twister_engine::extracts">extracts</a> the next value in the
  sequence and returns it.</p>

  <h3><code><a name="mersenne_twister_engine::tempering_b" id=
  "mersenne_twister_engine::tempering_b">mersenne_twister_engine::tempering_b</a></code></h3>
  <pre>
static constexpr UIntType <b>tempering_b</b> = B;
</pre>

  <p>The static const variable holds the value of the template argument <code>B</code>.</p>

  <h3><code><a name="mersenne_twister_engine::tempering_c" id=
  "mersenne_twister_engine::tempering_c">mersenne_twister_engine::tempering_c</a></code></h3>
  <pre>
static constexpr UIntType <b>tempering_c</b> = C;
</pre>

  <p>The static const variable holds the value of the template argument <code>C</code>.</p>

  <h3><code><a name="mersenne_twister_engine::tempering_d" id=
  "mersenne_twister_engine::tempering_d">mersenne_twister_engine::tempering_d</a></code></h3>
  <pre>
static constexpr UIntType <b>tempering_d</b> = D;
</pre>

  <p>The static const variable holds the value of the template argument <code>D</code>.</p>

  <h3><code><a name="mersenne_twister_engine::tempering_l" id=
  "mersenne_twister_engine::tempering_l">mersenne_twister_engine::tempering_l</a></code></h3>
  <pre>
static constexpr size_t <b>tempering_l</b> = L;
</pre>

  <p>The static const variable holds the value of the template argument <code>L</code>.</p>

  <h3><code><a name="mersenne_twister_engine::tempering_s" id=
  "mersenne_twister_engine::tempering_s">mersenne_twister_engine::tempering_s</a></code></h3>
  <pre>
static constexpr size_t <b>tempering_s</b> = S;
</pre>

  <p>The static const variable holds the value of the template argument <code>S</code>.</p>

  <h3><code><a name="mersenne_twister_engine::tempering_t" id=
  "mersenne_twister_engine::tempering_t">mersenne_twister_engine::tempering_t</a></code></h3>
  <pre>
static constexpr size_t <b>tempering_t</b> = T;
</pre>

  <p>The static const variable holds the value of the template argument <code>T</code>.</p>

  <h3><code><a name="mersenne_twister_engine::tempering_u" id=
  "mersenne_twister_engine::tempering_u">mersenne_twister_engine::tempering_u</a></code></h3>
  <pre>
static constexpr size_t <b>tempering_u</b> = U;
</pre>

  <p>The static const variable holds the value of the template argument <code>U</code>.</p>

  <h3><code><a name="mersenne_twister_engine::result_type" id=
  "mersenne_twister_engine::result_type">mersenne_twister_engine::result_type</a></code></h3>
  <pre>
typedef UIntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>UIntType</code>.</p>

  <h3><code><a name="mersenne_twister_engine::seed" id=
  "mersenne_twister_engine::seed">mersenne_twister_engine::seed</a></code></h3>
  <pre>
void <b>seed</b>(result_type x0 = default_seed);
void <b>seed</b>(seed_seq&amp; seq);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0 &lt; x0</code></p>

  <p>The first seed function sets the oldest historical value <code>h[0]</code> to <code>x0 mod
  2<sup>W</sup></code>, then iteratively sets each successive historical value <code>h[i]</code> to <code>(i
  + F * (h[i - 1] &gt;&gt; (W - 2))) mod 2<sup>W</sup></code>, for <code>i</code> ranging from <code>1</code>
  to <code>N - 1</code>.</p>

  <p>The second seed function sets the <code>N</code> historical values beginning with <code>h[0]</code> as
  follows:</p>

  <ul>
    <li><code>k</code> is the number of <i>unsigned long</i> integers needed to supply all the bits in a
    <code>UIntType</code> integer (at least 1).</li>

    <li><code>a</code> is an array of <code>N * k</code> elements of type <code>UIntType</code>.</li>

    <li><code>a</code> is initialized by calling <code>seq.generate(&amp;a[0], &amp;a[N * k])</code>.</li>

    <li>Each <code>h[i]</code> is composed by packing the <code>k</code> elements beginning at <code>a[i *
    k]</code>, which supplies the lowest-order bits.</li>
  </ul>

  <h3><code><a name="mersenne_twister_engine::shift_size" id=
  "mersenne_twister_engine::shift_size">mersenne_twister_engine::shift_size</a></code></h3>
  <pre>
static constexpr size_t <b>shift_size</b> = M;
</pre>

  <p>The static const variable holds the value of the template argument <code>M</code>.</p>

  <h3><code><a name="mersenne_twister_engine::state_size" id=
  "mersenne_twister_engine::state_size">mersenne_twister_engine::state_size</a></code></h3>
  <pre>
static constexpr size_t <b>state_size</b> = N;
</pre>

  <p>The static const variable holds the value of the template argument <code>N</code>.</p>

  <h3><code><a name="mersenne_twister_engine::word_size" id=
  "mersenne_twister_engine::word_size">mersenne_twister_engine::word_size</a></code></h3>
  <pre>
static constexpr size_t <b>word_size</b> = W;
</pre>

  <p>The static const variable holds the value of the template argument <code>W</code>.</p>

  <h3><code><a name="mersenne_twister_engine::xor_mask" id=
  "mersenne_twister_engine::xor_mask">mersenne_twister_engine::xor_mask</a></code></h3>
  <pre>
static constexpr UIntType <b>xor_mask</b> = A;
</pre>

  <p>The static const variable holds the value of the template argument <code>A</code>.</p>

  <h2><code><a name="minstd_rand" id="minstd_rand">minstd_rand</a></code></h2>
  <pre>
typedef linear_congruential&lt; <i>ui-type</i>, 48271, 0, 2147483647&gt; <b>minstd_rand</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>linear_congruential</code>.</p>

  <h2><code><a name="minstd_rand0" id="minstd_rand0">minstd_rand0</a></code></h2>
  <pre>
typedef linear_congruential&lt; <i>ui-type</i>, 16807, 0, 2147483647&gt; <b>minstd_rand0</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>linear_congruential</code>.</p>

  <h2><code><a name="mt19937" id="mt19937">mt19937</a></code></h2>
  <pre>
typedef mersenne_twister&lt; <i>ui-type</i>, 32, 624, 397, 31,
    0x9908b0df, 11, 7, 0x9d2c5680, 15, 0xefc60000, 18&gt; <b>mt19937</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>mersenne_twister</code>.</p>

  <h2><code><a name="mt19937_64" id="mt19937_64">mt19937_64</a></code></h2>
  <pre>
typedef mersenne_twister_engine&lt;<i>ui-type</i>, 64, 312, 156, 31,
    0xb5026f5aa96619e9ULL, 29, 0x5555555555555555ULL, 17,
    0x71d67fffeda60000ULL, 37, 0xfff7eee000000000ULL, 43,
    6364136223846793005ULL&gt; <b>mt19937_64</b> <b>[added with C++0X]</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>mersenne_twister_engine</code>.</p>

  <h2><code><a name="negative_binomial_distribution" id=
  "negative_binomial_distribution">negative_binomial_distribution</a></code></h2>
  <pre>
template&lt;class IntType = int&gt;
    class <b>negative_binomial_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef IntType <b><a href="#negative_binomial_distribution::result_type">result_type</a></b>;
    struct <b><a href="#negative_binomial_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#negative_binomial_distribution::negative_binomial_distribution">negative_binomial_distribution</a></b>(result_type k0 = 1,
        double p0 = 0.5);
    explicit <b><a href=
"#negative_binomial_distribution::negative_binomial_distribution">negative_binomial_distribution</a></b>(const param_type&amp; par0);

    result_type <b><a href="#negative_binomial_distribution::k">k</a></b>() const;
    double <b><a href="#negative_binomial_distribution::p">p</a></b>() const;
    param_type <b><a href="#negative_binomial_distribution::param">param</a></b>() const;
    void <b><a href="#negative_binomial_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#negative_binomial_distribution::min">min</a></b>() const;
    result_type <b><a href="#negative_binomial_distribution::max">max</a></b>() const;
    void <b><a href="#negative_binomial_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href=
"#negative_binomial_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href=
"#negative_binomial_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <b>stored_k</b>;  <i>// exposition only</i>
    double <b>stored_p</b>;       <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified integral type distributed with a binomial distribution.</p>

  <h3><code><a name="negative_binomial_distribution::k" id=
  "negative_binomial_distribution::k">negative_binomial_distribution::k</a></code></h3>
  <pre>
result_type <b>k</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_k</code>.</p>

  <h3><code><a name="negative_binomial_distribution::max" id=
  "negative_binomial_distribution::max">negative_binomial_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="negative_binomial_distribution::min" id=
  "negative_binomial_distribution::min">negative_binomial_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="negative_binomial_distribution::negative_binomial_distribution" id=
  "negative_binomial_distribution::negative_binomial_distribution">negative_binomial_distribution::negative_binomial_distribution</a></code></h3>
  <pre>
<b>negative_binomial_distribution</b>(result_type k0 = 1,
    double p0 = 0.5);
explicit <b>negative_binomial_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; k0 &amp;&amp; 0.0 &lt; p0
  &amp;&amp; p0 &lt;= 1.0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_p</code> holds the value
  <code>p0</code> and whose stored value <code>stored_k</code> holds the value <code>k0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name=
  "negative_binomial_distribution::operator()">negative_binomial_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns integral values with each value
  <code>i</code> occurring with probability:</p>
  <pre>
    <img src="negative_binomial_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="negative_binomial_distribution::p" id=
  "negative_binomial_distribution::p">negative_binomial_distribution::p</a></code></h3>
  <pre>
double <b>p</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_p</code>.</p>

  <h3><code><a name="negative_binomial_distribution::param" id=
  "negative_binomial_distribution::param">negative_binomial_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="negative_binomial_distribution::param_type" id=
  "negative_binomial_distribution::param_type">negative_binomial_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef negative_binomial_distribution&lt;IntType&gt; distribution_type;

    param_type(result_type t0 = 1, double p0 = 0.5);
    result_type k() const;
    double p() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="negative_binomial_distribution::reset" id=
  "negative_binomial_distribution::reset">negative_binomial_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="negative_binomial_distribution::result_type" id=
  "negative_binomial_distribution::result_type">negative_binomial_distribution::result_type</a></code></h3>
  <pre>
typedef IntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h2><code><a name="normal_distribution" id="normal_distribution">normal_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>normal_distribution</b> {
public:
    typedef T1 <b><a href="#normal_distribution::input_type">input_type</a></b>; <b>[removed with C++0X]</b>
    typedef RealType <b><a href="#normal_distribution::result_type">result_type</a></b>;
    struct <b><a href="#normal_distribution::param_type">param_type</a></b>; <b>[added with C++0X]</b>

    explicit <b><a href=
"#normal_distribution::normal_distribution">normal_distribution</a></b>(result_type mean0 = result_type(0.0),
        result_type sigma0 = result_type(1.0));
    explicit <b><a href=
"#normal_distribution::normal_distribution">normal_distribution</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#normal_distribution::mean">mean</a></b>() const;
    result_type <b><a href="#normal_distribution::sigma">sigma</a></b>() const;
    result_type <b><a href="#normal_distribution::stddev">stddev</a></b>() const; <b>[added with C++0X]</b>
    param_type <b><a href="#normal_distribution::param">param</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href=
"#normal_distribution::param">param</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#normal_distribution::min">min</a></b>() const; <b>[added with C++0X]</b>
    result_type <b><a href="#normal_distribution::max">max</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href="#normal_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#normal_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#normal_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0); <b>[added with C++0X]</b>

private:
    result_type <b>stored_mean</b>;     <i>// exposition only</i>
    result_type <b>stored_sigma</b>;    <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type with a normal distribution.</p>

  <h3><code><a name="normal_distribution::input_type" id=
  "normal_distribution::input_type">normal_distribution::input_type</a></code></h3>
  <pre>
typedef T1 <b>input_type</b>; <b>[removed with C++0X]</b>
</pre>

  <p>The type is a synonym for the implementation-defined type <code>T1</code>.</p>

  <h3><code><a name="normal_distribution::max" id=
  "normal_distribution::max">normal_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="normal_distribution::mean" id=
  "normal_distribution::mean">normal_distribution::mean</a></code></h3>
  <pre>
result_type <b>mean</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_mean</code>.</p>

  <h3><code><a name="normal_distribution::min" id=
  "normal_distribution::min">normal_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="normal_distribution::normal_distribution" id=
  "normal_distribution::normal_distribution">normal_distribution::normal_distribution</a></code></h3>
  <pre>
<b>normal_distribution</b>(result_type mean0 = result_type(0.0),
    result_type sigma0 = result_type(1.0));
explicit <b>normal_distribution</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; sigma0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_mean</code> holds the value
  <code>mean0</code> and whose stored value <code>stored_sigma</code> holds the value
  <code>sigma0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="normal_distribution::operator()">normal_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="normal_distribution.gif">
</pre>

  <h3><code><a name="normal_distribution::param" id=
  "normal_distribution::param">normal_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const; <b>[added with C++0X]</b>
void <b>param</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="normal_distribution::param_type" id=
  "normal_distribution::param_type">normal_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> { <b>[added with C++0X]</b>
    typedef normal_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type mean0 = result_type(0.0),
        RealType sigma0 = result_type(1.0));
    RealType mean() const;
    RealType sigma() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="normal_distribution::reset" id=
  "normal_distribution::reset">normal_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="normal_distribution::result_type" id=
  "normal_distribution::result_type">normal_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="normal_distribution::sigma" id=
  "normal_distribution::sigma">normal_distribution::sigma</a></code></h3>
  <pre>
result_type <b>sigma</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_sigma</code>.</p>

  <h3><code><a name="normal_distribution::stddev" id=
  "normal_distribution::stddev">normal_distribution::stddev</a></code></h3>
  <pre>
result_type <b>stddev</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the stored value <code>stored_sigma</code>.</p>

  <h2><code><a name="operator_ne" id="operator_ne">operator!=</a></code></h2>
  <pre>
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <b>operator!=</b>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <b>operator!=</b>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <b>operator!=</b>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <b>operator!=</b>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <b>operator!=</b>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <b>operator!=</b>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <b>operator!=</b>( <b>[added with C++0X]</b>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <b>operator!=</b>( <b>[added with C++0X]</b>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <b>operator!=</b>( <b>[added with C++0X]</b>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <b>operator!=</b>( <b>[added with C++0X]</b>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <b>operator!=</b>( <b>[added with C++0X]</b>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <b>operator!=</b>( <b>[added with C++0X]</b>
        const ahuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);
</pre>

  <p>The template operators return <code>!(left == right)</code>.</p>

  <h2><code><a name="operator_eq" id="operator_eq">operator==</a></code></h2>
  <pre>
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <b>operator==</b>(
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <b>operator==</b>(
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; left,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <b>operator==</b>(
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; left,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class RealType,
    int W, int S, int R&gt;
    bool <b>operator==</b>(
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; left,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Engine,
    int P, int R&gt;
    bool <b>operator==</b>(
        const discard_block&lt;Engine, F, R&gt;&amp; left,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    bool <b>operator==</b>(
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; left,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);
template&lt;class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    bool <b>operator==</b>( <b>[added with C++0X]</b>
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; left,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    bool <b>operator==</b>( <b>[added with C++0X]</b>
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; left,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class IntType,
    IntType M, int S, int R&gt;
    bool <b>operator==</b>( <b>[added with C++0X]</b>
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; left,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Engine,
    size_t P, size_t R&gt;
    bool <b>operator==</b>( <b>[added with C++0X]</b>
        const discard_block_engine&lt;Engine, F, R&gt;&amp; left,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Engine,
    size_t W, class UIntType&gt;
    bool <b>operator==</b>( <b>[added with C++0X]</b>
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; left,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Engine,
    size_t K&gt;
    bool <b>operator==</b>( <b>[added with C++0X]</b>
        const ahuffle_order_engine&lt;Engine, K&gt;&amp; left,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);
</pre>

  <p>The template operators return true if their engine operands have the same stored parameters and state.
  (They generate the same sequence.)</p>

  <h2><code><a name="operator_lsh" id="operator_lsh">operator&lt;&lt;</a></code></h2>
  <pre>
template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>(
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_ostream&lt;Elem, Traits&gt;&amp; <b>operator&lt;&lt;</b>( <b>[added with C++0X]</b>
        std::basic_ostream&lt;Elem, Traits&gt;&amp; ostr,
        const weibull_distribution&lt;RealType&gt;&amp; right);
</pre>

  <p>The template function inserts into the stream <code>ostr</code> sufficient information about
  <code>right</code> to restore its stored parameters with a subsequent extract. The stream must insert
  integer values as decimals.</p>

  <h2><code><a name="operator_rsh" id="operator_rsh">operator&gt;&gt;</a></code></h2>
  <pre>
template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister&lt;UIntType, W, N, M, R,
            A, U, S, B, T, C, L&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry&lt;IntType, M, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType,
    int W, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_01&lt;RealType, W, S, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    int P, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine1, int S1,
    class Engine2, int S2&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        xor_combine&lt;Engine1, S1, Engine2, S2&gt;&amp; right);

template&lt;class Elem, class Traits&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        bernoulli_distribution&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        binomial_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        exponential_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        gamma_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        geometric_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        normal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType
    class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        poisson_distribution&lt;IntType, RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>(
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real&lt;RealType&gt;&amp; right);

template&lt;class Elem, class Traits, class UIntType,
    UIntType A, UIntType C, UIntType M&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        linear_congruential_engine&lt;UIntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class UIntType,
    int W, int N, int M, int R,
    UIntType A, int U, int S,
    UIntType B, int T, UIntType C, int L&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        mersenne_twister_engine&lt;UIntType, W, N, M, R,
            A, U, D, S, B, T, C, L, F&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType,
    IntType M, int S, int R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        subtract_with_carry_engine&lt;IntType, A, C, M&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t P, size_t R&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discard_block_engine&lt;Engine, F, R&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t W, class UIntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        independent_bits_engine&lt;Engine, W, U&gt;&amp; right);
template&lt;class Elem, class Traits, class Engine,
    size_t K&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        shuffle_order_engine&lt;Engine, K&gt;&amp; right);

template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        cauchy_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        chi_squared_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        discrete_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        extreme_value_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        fisher_f_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        lognormal_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        negative_binomial_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        piecewise_constant_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        student_t_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class IntType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_int_distribution&lt;IntType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        uniform_real_distribution&lt;RealType&gt;&amp; right);
template&lt;class Elem, class Traits, class RealType&gt;
    std::basic_istream&lt;Elem, Traits&gt;&amp; <b>operator&gt;&gt;</b>( <b>[added with C++0X]</b>
        std::basic_istream&lt;Elem, Traits&gt;&amp; ostr,
        weibull_distribution&lt;RealType&gt;&amp; right);
</pre>

  <p>The template function extracts from the stream <code>istr</code> sufficient information into
  <code>right</code> to restore its stored parameters from a previous insert. The stream must extract integer
  values as decimals.</p>

  <h2><code><a name="piecewise_constant_distribution" id=
  "piecewise_constant_distribution">piecewise_constant_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>piecewise_constant_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#piecewise_constant_distribution::result_type">result_type</a></b>;
    struct <b><a href="#piecewise_constant_distribution::param_type">param_type</a></b>;

    <b><a href=
"#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</a></b>();
    template&lt;class InIt1, class InIt2&gt;
        <b><a href=
"#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</a></b>(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        <b><a href=
"#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</a></b>(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        <b><a href=
"#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</a></b>(size_t count,
            double low, double high, Fn func);
    explicit <b><a href=
"#piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution</a></b>(const param_type&amp; par0);

    std::vector&lt;double&gt; <b><a href=
"#piecewise_constant_distribution::densities">densities</a></b>() const;
    std::vector&lt;RealType&gt; <b><a href=
"#piecewise_constant_distribution::intervals">intervals</a></b>() const;
    param_type <b><a href="#piecewise_constant_distribution::param">param</a></b>() const;
    void <b><a href="#piecewise_constant_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#piecewise_constant_distribution::min">min</a></b>() const;
    result_type <b><a href="#piecewise_constant_distribution::max">max</a></b>() const;
    void <b><a href="#piecewise_constant_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href=
"#piecewise_constant_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href=
"#piecewise_constant_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    std::vector&lt;double&gt; <b>stored_p</b>;    <i>// exposition only</i>
    std::vector&lt;RealType&gt; <b>stored_x</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed according to a varying-width histogram of
  probabilities.</p>

  <p>Three distributions are very similar:</p>

  <ul>
    <li>A <code><a href="#discrete_distribution">discrete_distribution</a></code> has uniform-width intervals
    with uniform probability in each interval.</li>

    <li>A <code>piecewise_constant_distribution</code> has varying-width intervals with uniform probability
    in each interval.</li>

    <li>A <code><a href="#piecewise_linear_distribution">piecewise_linear_distribution</a></code> has
    varying-width intervals with linearly varying probability over each interval.</li>
  </ul>

  <h3><code><a name="piecewise_constant_distribution::densities" id=
  "piecewise_constant_distribution::densities">piecewise_constant_distribution::densities</a></code></h3>
  <pre>
std::vector&lt;double&gt; <b>densities</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_p</code>, with each element
  <code>stored_p[I]</code> divided by <code>stored_x[I + 1] - stored_x[I]</code>.</p>

  <h3><code><a name="piecewise_constant_distribution::intervals" id=
  "piecewise_constant_distribution::intervals">piecewise_constant_distribution::intervals</a></code></h3>
  <pre>
std::vector&lt;RealType&gt; <b>intervals</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_x</code>.</p>

  <h3><code><a name="piecewise_constant_distribution::max" id=
  "piecewise_constant_distribution::max">piecewise_constant_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="piecewise_constant_distribution::min" id=
  "piecewise_constant_distribution::min">piecewise_constant_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name=
  "piecewise_constant_distribution::operator()">piecewise_constant_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> in the range <code>[stored_x.front(), stored_x.back())</code> occurring with probability
  determined by the smallest element <code>I</code> for which <code>x &lt; stored_x[I + 1}</code>, and other
  values of <code>x</code> occurring with probability zero. Values <code>x</code> are uniformly distributed
  over the range <code>[stored_x[I], stored_x[I + 1])</code> with total probability
  <code>stored_p[I]</code>.</p>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="piecewise_constant_distribution::param" id=
  "piecewise_constant_distribution::param">piecewise_constant_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="piecewise_constant_distribution::param_type" id=
  "piecewise_constant_distribution::param_type">piecewise_constant_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef piecewise_constant_distribution&lt;RealType&gt; distribution_type;

    param_type();
    template&lt;class InIt1, class InIt2&gt;
        param_type(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        param_type(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);

    std::vector&lt;double&gt; densities() const;
    std::vector&lt;RealType&gt; intervals() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="piecewise_constant_distribution::piecewise_constant_distribution" id=
  "piecewise_constant_distribution::piecewise_constant_distribution">piecewise_constant_distribution::piecewise_constant_distribution</a></code></h3>
  <pre>
<b>piecewise_constant_distribution</b>();
template&lt;class InIt1, class InIt2&gt;
    <b>piecewise_constant_distribution</b>(InIt1 first1, InIt1 last1,
        InIt2 first2);
template&lt;class Fn&gt;
    <b>piecewise_constant_distribution</b>(initializer_list&lt;RealType&gt; init, Fn func);
template&lt;class Fn&gt;
    <b>piecewise_constant_distribution</b>(size_t count,
        double low, double high, Fn func);
explicit <b>piecewise_constant_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> All elements to be stored in
  <code>stored_p</code> are nonnegative and at least one is nonzero.</p>

  <p>The first constructor constructs an object whose stored value <code>stored_x</code> holds the values
  <code>RealType(0.0)</code> and <code>RealType(1.0)</code>, and whose stored value <code>stored_p</code>
  holds the value <code>1.0</code>.</p>

  <p>The second constructor constructs an object whose stored value <code>stored_x</code> is initialized with
  the sequence <code>[first1, last1)</code>. If the sequence has fewer than two elements,
  <code>stored_x</code> has two elements <code>RealType(0.0)</code> and <code>RealType(1.0)</code>, and
  <code>stored_p</code> has one element with value 1. Otherwise, <code>stored_p</code> is initialized with
  <code>stored_x.size() - 1</code> elements beginning at <code>first2</code>, then normalized so that the sum
  of all elements is 1.</p>

  <p>The third constructor constructs an object whose stored value <code>stored_x</code> is initialized with
  the sequence <code>[init.begin(), init.end())</code>. Its stored value <code>stored_p</code> is initialized
  with <code>init.size() - 1</code> elements, where element <code>I</code> stores the value
  <code>func(x)</code> for <code>x</code> in the middle of subrange <code>[stored_x[I], stored_x[I +
  1]]</code>. If <code>count &lt; 1</code>, <code>stored_p</code> has one element with value 1.</p>

  <p>The fourth constructor constructs an object whose stored value <code>stored_p</code> is initialized with
  <code>count</code> elements. It divides the range <code>high - low</code> into <code>count</code>
  subranges, then stores in element <code>I</code> the value <code>func(x)</code> for <code>x</code> in the
  middle of subrange <code>I</code>. It stores in <code>stored_x</code> the <code>count + 1</code> endpoints
  of these subranges. If <code>count &lt; 1</code>, <code>stored_p</code> has one element with value 1.</p>

  <p>The fifth constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="piecewise_constant_distribution::result_type" id=
  "piecewise_constant_distribution::result_type">piecewise_constant_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="piecewise_constant_distribution::reset" id=
  "piecewise_constant_distribution::reset">piecewise_constant_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h2><code><a name="piecewise_linear_distribution" id=
  "piecewise_linear_distribution">piecewise_linear_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>piecewise_linear_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#piecewise_linear_distribution::result_type">result_type</a></b>;
    struct <b><a href="#piecewise_linear_distribution::param_type">param_type</a></b>;

    <b><a href=
"#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</a></b>();
    template&lt;class InIt1, class InIt2&gt;
        <b><a href=
"#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</a></b>(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        <b><a href=
"#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</a></b>(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        <b><a href=
"#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</a></b>(size_t count,
            double low, double high, Fn func);
    explicit <b><a href=
"#piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution</a></b>(const param_type&amp; par0);

    std::vector&lt;double&gt; <b><a href=
"#piecewise_linear_distribution::densities">densities</a></b>() const;
    std::vector&lt;RealType&gt; <b><a href=
"#piecewise_linear_distribution::intervals">intervals</a></b>() const;
    param_type <b><a href="#piecewise_linear_distribution::param">param</a></b>() const;
    void <b><a href="#piecewise_linear_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#piecewise_linear_distribution::min">min</a></b>() const;
    result_type <b><a href="#piecewise_linear_distribution::max">max</a></b>() const;
    void <b><a href="#piecewise_linear_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href=
"#piecewise_linear_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href=
"#piecewise_linear_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    std::vector&lt;double&gt; <b>stored_p</b>;    <i>// exposition only</i>
    std::vector&lt;RealType&gt; <b>stored_x</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed according to a varying-width histogram of
  probabilities, with probability varying linearly over each interval.</p>

  <p>Three distributions are very similar:</p>

  <ul>
    <li>A <code><a href="#discrete_distribution">discrete_distribution</a></code> has uniform-width intervals
    with uniform probability in each interval.</li>

    <li>A <code><a href="#piecewise_constant_distribution">piecewise_constant_distribution</a></code> has
    varying-width intervals with uniform probability in each interval.</li>

    <li>A <code>piecewise_linear_distribution</code> has varying-width intervals with linearly varying
    probability over each interval.</li>
  </ul>

  <h3><code><a name="piecewise_linear_distribution::densities" id=
  "piecewise_linear_distribution::densities">piecewise_linear_distribution::densities</a></code></h3>
  <pre>
std::vector&lt;double&gt; <b>densities</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_p</code>.</p>

  <h3><code><a name="piecewise_linear_distribution::intervals" id=
  "piecewise_linear_distribution::intervals">piecewise_linear_distribution::intervals</a></code></h3>
  <pre>
std::vector&lt;RealType&gt; <b>intervals</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_x</code>.</p>

  <h3><code><a name="piecewise_linear_distribution::max" id=
  "piecewise_linear_distribution::max">piecewise_linear_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="piecewise_linear_distribution::min" id=
  "piecewise_linear_distribution::min">piecewise_linear_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name=
  "piecewise_linear_distribution::operator()">piecewise_linear_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> in the range <code>[stored_x.front(), stored_x.back())</code> occurring with probability
  determined by the smallest element <code>I</code> for which <code>x &lt; stored_x[I + 1}</code>, and other
  values of <code>x</code> occurring with probability zero. Values <code>x</code> are uniformly distributed
  over the range <code>[stored_x[I], stored_x[I + 1])</code> with probability varying from
  <code>stored_p[I]</code> to <code>stored_p[I + 1]</code>.</p>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="piecewise_linear_distribution::param" id=
  "piecewise_linear_distribution::param">piecewise_linear_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="piecewise_linear_distribution::param_type" id=
  "piecewise_linear_distribution::param_type">piecewise_linear_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef piecewise_linear_distribution&lt;RealType&gt; distribution_type;

    param_type();
    template&lt;class InIt1, class InIt2&gt;
        param_type(InIt1 first1, InIt1 last1,
            InIt2 first2);
    template&lt;class Fn&gt;
        param_type(initializer_list&lt;RealType&gt; init, Fn func);
    template&lt;class Fn&gt;
        param_type(size_t count,
            double low, double high, Fn func);

    std::vector&lt;double&gt; densities() const;
    std::vector&lt;RealType&gt; intervals() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="piecewise_linear_distribution::piecewise_linear_distribution" id=
  "piecewise_linear_distribution::piecewise_linear_distribution">piecewise_linear_distribution::piecewise_linear_distribution</a></code></h3>
  <pre>
<b>piecewise_linear_distribution</b>();
template&lt;class InIt1, class InIt2&gt;
    <b>piecewise_linear_distribution</b>(InIt1 first1, InIt1 last1,
        InIt2 first2);
template&lt;class Fn&gt;
    <b>piecewise_linear_distribution</b>(initializer_list&lt;RealType&gt; init, Fn func);
template&lt;class Fn&gt;
    <b>piecewise_linear_distribution</b>(size_t count,
        double low, double high, Fn func);
explicit <b>piecewise_linear_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> All elements to be stored in
  <code>stored_p</code> are nonnegative and at least one is nonzero.</p>

  <p>The first constructor constructs an object whose stored value <code>stored_x</code> holds the values
  <code>RealType(0.0)</code> and <code>RealType(1.0)</code>, and whose stored value <code>stored_p</code>
  holds the values <code>1.0</code> and <code>1.0</code>.</p>

  <p>The second constructor constructs an object whose stored value <code>stored_x</code> is initialized with
  the sequence <code>[first1, last1)</code>. <code>stored_p</code> is initialized with
  <code>stored_x.size()</code> elements beginning at <code>first2</code>.</p>

  <p>The third constructor constructs an object whose stored value <code>stored_x</code> is initialized with
  the sequence <code>[init.begin(), init.end())</code>. Its stored value <code>stored_p</code> is initialized
  with <code>init.size()</code> elements, where element <code>I</code> stores the value
  <code>func(stored_x[I])</code>.</p>

  <p>The fourth constructor constructs an object whose stored value <code>stored_p</code> is initialized with
  <code>count</code> elements. It divides the range <code>high - low</code> into <code>count</code>
  subranges, then stores in element <code>I</code> the value <code>func(x)</code> for <code>x</code> in the
  middle of subrange <code>I</code>. It stores in <code>stored_x</code> the <code>count + 1</code> endpoints
  of these subranges.</p>

  <p>The fifth constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <p>In all cases, if the sequence has fewer than two elements, <code>stored_x</code> has two elements
  <code>RealType(0.0)</code> and <code>RealType(1.0)</code>, and <code>stored_p</code> has two elements with
  value 1. Also, <code>stored_p</code> is normalized so that the sum of all probability intervals is 1.</p>

  <h3><code><a name="piecewise_linear_distribution::result_type" id=
  "piecewise_linear_distribution::result_type">piecewise_linear_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="piecewise_linear_distribution::reset" id=
  "piecewise_linear_distribution::reset">piecewise_linear_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h2><code><a name="poisson_distribution" id="poisson_distribution">poisson_distribution</a></code></h2>
  <pre>
template&lt;class IntType = int,
    class RealType = double&gt; <b>[always double with C++0X]</b>
    class <b>poisson_distribution</b> {
public:
    typedef T1 <b><a href="#poisson_distribution::input_type">input_type</a></b>; <b>[removed with C++0X]</b>
    typedef IntType <b><a href="#poisson_distribution::result_type">result_type</a></b>;
    struct <b><a href="#poisson_distribution::param_type">param_type</a></b>; <b>[added with C++0X]</b>

    explicit <b><a href=
"#poisson_distribution::poisson_distribution">poisson_distribution</a></b>(RealType mean0 = RealType(1.0));
    explicit <b><a href=
"#poisson_distribution::poisson_distribution">poisson_distribution</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    RealType <b><a href="#poisson_distribution::mean">mean</a></b>() const;
    param_type <b><a href="#poisson_distribution::param">param</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href=
"#poisson_distribution::param">param</a></b>(const param_type&amp; par0); <b>[added with C++0X]</b>

    result_type <b><a href="#poisson_distribution::min">min</a></b>() const; <b>[added with C++0X]</b>
    result_type <b><a href="#poisson_distribution::max">max</a></b>() const; <b>[added with C++0X]</b>
    void <b><a href="#poisson_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#poisson_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#poisson_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0); <b>[added with C++0X]</b>

private:
    RealType <b>stored_mean</b>;     <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified integral type with a Poisson distribution.</p>

  <h3><code><a name="poisson_distribution::input_type" id=
  "poisson_distribution::input_type">poisson_distribution::input_type</a></code></h3>
  <pre>
typedef T1 <b>input_type</b>; <b>[removed with C++0X]</b>
</pre>

  <p>The type is a synonym for the implementation-defined type <code>T1</code>.</p>

  <h3><code><a name="poisson_distribution::max" id=
  "poisson_distribution::max">poisson_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="poisson_distribution::mean" id=
  "poisson_distribution::mean">poisson_distribution::mean</a></code></h3>
  <pre>
RealType <b>mean</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_mean</code>.</p>

  <h3><code><a name="poisson_distribution::min" id=
  "poisson_distribution::min">poisson_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const; <b>[added with C++0X]</b>
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="poisson_distribution::operator()">poisson_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed integral values and returns integral values with each value <code>i</code>
  occurring with probability:</p>
  <pre>
    <img src="poisson_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="poisson_distribution::param" id=
  "poisson_distribution::param">poisson_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const; <b>[added with C++0X]</b>
void <b>param</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="poisson_distribution::param_type" id=
  "poisson_distribution::param_type">poisson_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> { <b>[added with C++0X]</b>
    typedef poisson_distribution&lt;IntType, RealType&gt; distribution_type;

    param_type(RealType mean = RealType(1.0));
    RealType mean() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="poisson_distribution::poisson_distribution" id=
  "poisson_distribution::poisson_distribution">poisson_distribution::poisson_distribution</a></code></h3>
  <pre>
<b>poisson_distribution</b>(RealType mean0 = RealType(1.0));
explicit <b>binomial_distribution</b>(const param_type&amp; par0); <b>[added with C++0X]</b>
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; mean0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_mean</code> holds the value
  <code>mean0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h3><code><a name="poisson_distribution::reset" id=
  "poisson_distribution::reset">poisson_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="poisson_distribution::result_type" id=
  "poisson_distribution::result_type">poisson_distribution::result_type</a></code></h3>
  <pre>
typedef IntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h2><code><a name="random_device" id="random_device">random_device</a></code></h2>
  <pre>
class random_device {
public:
    typedef unsigned int <b><a href="#random_device::result_type">result_type</a></b>;

    explicit <b><a href=
"#random_device::random_device">random_device</a></b>(const std::string&amp; token = /* <i>implementation defined</i> */);

    result_type <b><a href="#random_device::min">min</a></b>() const;
    result_type <b><a href="#random_device::max">max</a></b>() const;
    double <b><a href="#random_device::entropy">entropy</a></b>() const;
    result_type <b><a href="#random_device::operator()">operator()</a></b>();

private:
    <b>random_device</b>(const random_device&amp;) = delete; <b>[added with C++0X]</b>
    void <b>operator=</b>(const random_device&amp;) = delete; <b>[added with C++0X]</b>
    };
</pre>

  <p>The class decribes a source of random numbers, preferably from a non-deterministic external device. In
  this implementation the values produced by default are not non-deterministic. They are uniformly
  distributed in the closed range <code>[0, 65535]</code>.</p>

  <h3><code><a name="random_device::entropy" id=
  "random_device::entropy">random_device::entropy</a></code></h3>
  <pre>
double <b>entropy</b>() const;
</pre>

  <p>The member function returns an estimate of the randomness of the source, as measured in bits. (In the
  extreme, a non-random source has an entropy of zero.)</p>

  <h3><code><a name="random_device::max" id="random_device::max">random_device::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returned by the source.</p>

  <h3><code><a name="random_device::min" id="random_device::min">random_device::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returned by the source.</p>

  <h3><code><a name="random_device::operator()">random_device::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function returns values uniformly distributed in the closed interval <code>[min(),
  max()]</code>.</p>

  <h3><code><a name="random_device::random_device" id=
  "random_device::random_device">random_device::random_device</a></code></h3>
  <pre>
<b>random_device</b>(const std::string&amp; str = /* <i>implementation defined</i> */);
</pre>

  <p>The constructor initializes the device (as needed) with <code>str</code>.</p>

  <h3><code><a name="random_device::result_type" id=
  "random_device::result_type">random_device::result_type</a></code></h3>
  <pre>
typedef unsigned int <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>unsigned int</code>.</p>

  <h2><code><a name="ranlux_base_01" id="ranlux_base_01">ranlux_base_01</a></code></h2>
  <pre>
typedef subtract_with_carry_01&lt;float, 24, 10, 24&gt; <b>ranlux_base_01</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>subtract_with_carry_01</code>.</p>

  <h2><code><a name="ranlux24" id="ranlux24">ranlux24</a></code></h2>
  <pre>
typedef discard_block_engine&lt;ranlux_24_base, 223, 23&gt;
    <b>ranlux24</b>; <b>[added with C++0X]</b>
</pre>

  <p>The type is a synonym for a specialization of the template <code>discard_block_engine</code> with a
  specialization of the template <code>subtract_with_carry_engine</code>.</p>

  <h2><code><a name="ranlux24_base" id="ranlux24_base">ranlux24_base</a></code></h2>
  <pre>
typedef subtract_with_carry_engine&lt;<i>ui-type</i>, 24, 10, 24&gt;
    <b>ranlux24_base</b>; <b>[added with C++0X]</b>
</pre>

  <p>The type is a synonym for a specialization of the template <code>subtract_with_carry_engine</code>.</p>

  <h2><code><a name="ranlux3" id="ranlux3">ranlux3</a></code></h2>
  <pre>
typedef discard_block&lt;subtract_with_carry&lt; <i>ui-type</i>, 1 &lt;&lt; 24, 10, 24&gt;
    223, 24&gt; <b>ranlux3</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>discard_block</code> with a
  specialization of the template <code>subtract_with_carry</code>.</p>

  <h2><code><a name="ranlux3_01" id="ranlux3_01">ranlux3_01</a></code></h2>
  <pre>
typedef discard_block&lt;ranlux_base_01, 223, 24&gt; <b>ranlux3_01</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>discard_block</code> with a
  specialization of the template <code>subtract_with_carry_01</code>.</p>

  <h2><code><a name="ranlux4" id="ranlux4">ranlux4</a></code></h2>
  <pre>
typedef discard_block&lt;subtract_with_carry&lt; <i>ui-type</i>, 1 &lt;&lt; 24, 10, 24&gt;,
    389, 24&gt; <b>ranlux4</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>discard_block</code> with a
  specialization of the template <code>subtract_with_carry</code>.</p>

  <h2><code><a name="ranlux4_01" id="ranlux4_01">ranlux4_01</a></code></h2>
  <pre>
typedef discard_block&lt;ranlux_base_01, 389, 24&gt; <b>ranlux4_01</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>discard_block</code> with a
  specialization of the template <code>subtract_with_carry_01</code>.</p>

  <h2><code><a name="ranlux48" id="ranlux48">ranlux48</a></code></h2>
  <pre>
typedef discard_block_engine&lt;ranlux_48_base, 389, 11&gt;
    <b>ranlux48</b>; <b>[added with C++0X]</b>
</pre>

  <p>The type is a synonym for a specialization of the template <code>discard_block_engine</code> with a
  specialization of the template <code>subtract_with_carry_engine</code>.</p>

  <h2><code><a name="ranlux48_base" id="ranlux48_base">ranlux48_base</a></code></h2>
  <pre>
typedef subtract_with_carry_engine&lt;<i>ui-type</i>, 48, 5, 12&gt;
    <b>ranlux48_base</b>; <b>[added with C++0X]</b>
</pre>

  <p>The type is a synonym for a specialization of the template <code>subtract_with_carry_engine</code>.</p>

  <h2><code><a name="ranlux64_base_01" id="ranlux64_base_01">ranlux64_base_01</a></code></h2>
  <pre>
typedef subtract_with_carry_01&lt;double, 48, 10, 24&gt; <b>ranlux64_base_01</b>;
</pre>

  <p>The type is a synonym for a specialization of the template <code>subtract_with_carry_01</code>.</p>

  <h2><code><a name="seed_seq" id="seed_seq">seed_seq</a></code></h2>
  <pre>
class <b>seed_seq</b> { <b>[added with C++0X]</b>
public:
    typedef uint_least32_t <b><a href="#seed_seq::result_type">result_type</a></b>;

    <b><a href="#seed_seq::seed_seq">seed_seq</a></b>();
    template&lt;class Ty&gt;
        <b><a href="#seed_seq::seed_seq">seed_seq</a></b>(initializer_list&lt;Ty&gt; init);
    template&lt;class InIt&gt;
        <b><a href="#seed_seq::seed_seq">seed_seq</a></b>(InIt first, InIt last);

    template&lt;class RanIt&gt;
        void <b><a href="#seed_seq::generate">generate</a></b>(RanIt first, RanIt last,
            size_t inbits = numeric_limits&lt;typename iterator_traits&lt;
                InIt&gt;::value_type&gt;::digits) const;
    size_t <b>size</b>() const;
    template&lt;class OutIt&gt;
        void <b><a href="#seed_seq::param">param</a></b>(OutIt dest) const;

private:
    vector&lt;result_type&gt; <b>vec</b>;    <i>// exposition only</i>
    };
</pre>

  <p>The class stores a vector of unsigned integer values that can supply a randomized seed for a
  random-number engine.</p>

  <h3><code><a name="seed_seq::generate" id="seed_seq::generate">seed_seq::generate</a></code></h3>
  <pre>
template&lt;class RanIt&gt;
    void <b>generate</b>(RanIt first, RanIt last) const;
</pre>

  <p>The template function initializes the elements of the sequence <code>[first, last)</code> (if the
  sequence is non-empty) as follows:</p>
  <pre>
const size_t s = vec.size();
const size_t n = last - first;
const size_t t = 623 &lt;= n ? 11 : 68 &lt;= n ? 7
    : 39 &lt;= n ? 5 : 7 &lt;= n ? 3 : (n - 1) / 2;
const size_t p = (n - t) / 2;
const size_t q = p + t;
const size_t m = n &lt;= s ? s + 1 : n;
size_t k;

for (k = 0; k &lt; n; ++k)
    first[k] = 0x8b8b8b8b;

for (k = 0; k &lt; m; ++k)
    {    // scramble and add any vector contribution
    result_type r1 = 1664525
        * xor27(first[k % n] ^ first[(k + p) % n] ^ first[(k - 1) % n]);
    result_type r2 = r1
        + (k == 0 ? s : k &lt;= s ? k % n + vec[k - 1] : k % n);

    first[(k + p) % n] += r1;
    first[(k + q) % n] += r2;
    first[k] = r2;
    }

for (; k &lt; m + n; ++k)
    {    // rescramble
    result_type r3 = 1566083941
        * xor27(first[k % n] + first[(k + p) % n] + first[(k - 1) % n]);
    result_type r4 = r3 - k % n;

    first[(k + p) % n] ^= r3;
    first[(k + q) % n] ^= r4;
    first[k] = r4;
    }
</pre>

  <p>The function <code>xor27</code> is defined as:</p>
  <pre>
result_type xor27(result_type val) const
    {    // shift and merge
    return (val ^ (val &gt;&gt; 27));
    }
</pre>

  <h3><code><a name="seed_seq::param" id="seed_seq::param">seed_seq::param</a></code></h3>
  <pre>
template&lt;class OutIt&gt;
    void <b>param</b>(OutIt dest) const;
</pre>

  <p>The template function executes <code>copy(vec.begin(), vec.end(), dest)</code>.</p>

  <h3><code><a name="seed_seq::result_type" id="seed_seq::result_type">seed_seq::result_type</a></code></h3>
  <pre>
typedef uint_least32_t <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>uint_least32_t</code>.</p>

  <h3><code><a name="seed_seq::seed_seq" id="seed_seq::seed_seq">seed_seq::seed_seq</a></code></h3>
  <pre>
<b>seed_seq</b>();
template&lt;class Ty&gt;
    <b>seed_seq</b>(initializer_list&lt;Ty&gt; init);
template&lt;class InIt&gt;
    <b>seed_seq</b>(InIt first, InIt last,
        size_t inbits = numeric_limits&lt;typename iterator_traits&lt;
            InIt&gt;::value_type&gt;::digits);
</pre>

  <p>The first constructor initializes <code>vec</code> to an empty vector. The second constructor
  initializes <code>vec</code> with a sequence of elements in <code>[init.begin(), init.end())</code>, each
  reduced modulo 2^32. The third constructor initializes <code>vec</code> with a sequence of elements in
  <code>[first, last)</code>, each reduced modulo 2^32.</p>

  <h2><code><a name="shuffle_order_engine" id="shuffle_order_engine">shuffle_order_engine</a></code></h2>
  <pre>
template&lt;class Engine,
    size_t K&gt;
    class <b>shuffle_order_engine</b> { <b>[added with C++0X]</b>
public:
    typedef Engine <b><a href="#shuffle_order_engine::base_type">base_type</a></b>;
    typedef typename base_type::result_type <b><a href=
"#shuffle_order_engine::result_type">result_type</a></b>;

    static constexpr size_t <b><a href="#shuffle_order_engine::table_size">table_size</a></b> = K;

    <b><a href="#shuffle_order_engine::shuffle_order_engine">shuffle_order_engine</a></b>();
    explicit <b><a href=
"#shuffle_order_engine::shuffle_order_engine">shuffle_order_engine</a></b>(const base_type&amp; eng);
    explicit <b><a href=
"#shuffle_order_engine::shuffle_order_engine">shuffle_order_engine</a></b>(result_type x0);
    explicit <b><a href=
"#shuffle_order_engine::shuffle_order_engine">shuffle_order_engine</a></b>(seed_seq&amp; seq);
    void <b><a href="#shuffle_order_engine::seed">seed</a></b>();
    void <b><a href="#shuffle_order_engine::seed">seed</a></b>(result_type x0);
    void <b><a href="#shuffle_order_engine::seed">seed</a></b>(seed_seq&amp; seq);

    const base_type&amp; <b><a href="#shuffle_order_engine::base">base</a></b>() const;
    static constexpr result_type <b><a href="#shuffle_order_engine::min">min</a></b>();
    static constexpr result_type <b><a href="#shuffle_order_engine::max">max</a></b>();
    result_type <b><a href="#shuffle_order_engine::operator()">operator()</a></b>();
    void <b><a href="#shuffle_order_engine::discard">discard</a></b>(unsigned long long count);

private:
    Engine <b>stored_eng</b>;         <i>// exposition only</i>
    result_type <b>stored_arr[K]</b>; <i>// exposition only</i>
    result_type <b>stored_y</b>;      <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#compound%20engine">compound engine</a> that
  produces values by reordering the values returned by its base engine. Each constructor fills the array
  <code>stored_arr</code> with <code>K</code> values returned by the base engine. It then stores in
  <code>stored_y</code> an additional value returned by the base engine. Each element of the generated
  sequence is then obtained from <code>stored_y</code>, after which:</p>

  <ul>
    <li>The array index <code>J</code> is computed as <code>K * (stored_y - min()) / (max() - min() +
    1)</code>.</li>

    <li><code>stored_y</code> is replaced by <code>stored_arr[J]</code>.</li>

    <li><code>stored_arr[j]</code> is replaced by <code>stored_eng()</code>.</li>
  </ul>

  <p>The engine's <a href="lib_rand.html#state">state</a> is the state of <code>stored_eng</code>, followed
  by the <code>K</code> elements of <code>stored_arr</code>, followed by <code>stored_y</code>.</p>

  <p>The value of the template argument <code>K</code> must be greater than zero.</p>

  <h3><code><a name="shuffle_order_engine::base" id=
  "shuffle_order_engine::base">shuffle_order_engine::base</a></code></h3>
  <pre>
const base_type&amp; <b>base</b>() const;
</pre>

  <p>The member function returns a reference to the underlying engine object.</p>

  <h3><code><a name="shuffle_order_engine::base_type" id=
  "shuffle_order_engine::base_type">shuffle_order_engine::base_type</a></code></h3>
  <pre>
typedef Engine <b>base_type</b>;
</pre>

  <p>The type is a synonym for the type of the underlying engine object.</p>

  <h3><code><a name="shuffle_order_engine::discard" id=
  "shuffle_order_engine::discard">shuffle_order_engine::discard</a></code></h3>
  <pre>
void <b>discard</b>(unsigned long long count);
</pre>

  <p>The member function effectively calls <code>(*this)()</code> <code>count</code> times.</p>

  <h3><code><a name="shuffle_order_engine::shuffle_order_engine" id=
  "shuffle_order_engine::shuffle_order_engine">shuffle_order_engine::shuffle_order_engine</a></code></h3>
  <pre>
<b>shuffle_order_engine</b>();
explicit <b>shuffle_order_engine</b>(const base_type&amp; eng);
explicit <b>shuffle_order_engine</b>(result_type x0);
explicit <b>shuffle_order_engine</b>(seed_seq&amp; seq);
</pre>

  <p>The first constructor constructs a <code>shuffle_order_engine</code> object with a default-initialized
  engine. The second contructor constructs a <code>shuffle_order_engine</code> object with a copy of an
  engine object. The third constructor constucts a <code>shuffle_order_engine</code> object with its engine
  initialized by <code>stored_engine(x0)</code>. The fourth constructor constucts a
  <code>shuffle_order_engine</code> object with its engine initialized by
  <code>stored_engine(seq)</code>.</p>

  <h3><code><a name="shuffle_order_engine::max" id=
  "shuffle_order_engine::max">shuffle_order_engine::max</a></code></h3>
  <pre>
static constexpr result_type <b>max</b>();
</pre>

  <p>The static member function returns <code>Engine::max()</code>.</p>

  <h3><code><a name="shuffle_order_engine::min" id=
  "shuffle_order_engine::min">shuffle_order_engine::min</a></code></h3>
  <pre>
static constexpr result_type <b>min</b>();
</pre>

  <p>The static member function returns <code>Engine::min()</code>.</p>

  <h3><code><a name="shuffle_order_engine::operator()">shuffle_order_engine::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function returns the next value in the sequence.</p>

  <h3><code><a name="shuffle_order_engine::result_type" id=
  "shuffle_order_engine::result_type">shuffle_order_engine::result_type</a></code></h3>
  <pre>
typedef typename base_type::result_type <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>base_type::result_type</code>.</p>

  <h3><code><a name="shuffle_order_engine::seed" id=
  "shuffle_order_engine::seed">shuffle_order_engine::seed</a></code></h3>
  <pre>
void <b>seed</b>();
void <b>seed</b>(result_type x0);
void <b>seed</b>(seed_seq&amp; seq);
</pre>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> calls
  <code>stored_eng.seed()</code>. The second seed function calls <code>stored_eng.seed(x0)</code>. The second
  seed function calls <code>stored_eng.seed(seq)</code>.</p>

  <h3><code><a name="shuffle_order_engine::table_size" id=
  "shuffle_order_engine::table_size">shuffle_order_engine::table_size</a></code></h3>
  <pre>
static constexpr size_t <b>table_size</b> = K;
</pre>

  <p>The static const variable has the same value as the template parmaeter <code>K</code>.</p>

  <h2><code><a name="student_t_distribution" id=
  "student_t_distribution">student_t_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>student_t_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#student_t_distribution::result_type">result_type</a></b>;
    struct <b><a href="#student_t_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#student_t_distribution::student_t_distribution">student_t_distribution</a></b>(RealType n0 = 1);
    explicit <b><a href=
"#student_t_distribution::student_t_distribution">student_t_distribution</a></b>(const param_type&amp; par0);

    RealType <b><a href="#student_t_distribution::n">n</a></b>() const;
    param_type <b><a href="#student_t_distribution::param">param</a></b>() const;
    void <b><a href="#student_t_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#student_t_distribution::min">min</a></b>() const;
    result_type <b><a href="#student_t_distribution::max">max</a></b>() const;
    void <b><a href="#student_t_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#student_t_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#student_t_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    RealType <b>stored_n</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed with a Student T distribution.</p>

  <h3><code><a name="student_t_distribution::max" id=
  "student_t_distribution::max">student_t_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="student_t_distribution::min" id=
  "student_t_distribution::min">student_t_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="student_t_distribution::n" id=
  "student_t_distribution::n">student_t_distribution::n</a></code></h3>
  <pre>
RealType <b>n</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_n</code>.</p>

  <h3><code><a name="student_t_distribution::operator()">student_t_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="student_t_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="student_t_distribution::param" id=
  "student_t_distribution::param">student_t_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="student_t_distribution::param_type" id=
  "student_t_distribution::param_type">student_t_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef student_t_distribution&lt;RealType&gt; distribution_type;

    param_type(RealType n0 = 1);
    RealType n() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="student_t_distribution::reset" id=
  "student_t_distribution::reset">student_t_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="student_t_distribution::result_type" id=
  "student_t_distribution::result_type">student_t_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="student_t_distribution::student_t_distribution" id=
  "student_t_distribution::student_t_distribution">student_t_distribution::student_t_distribution</a></code></h3>
  <pre>
<b>student_t_distribution</b>(RealType n0 = 1);
explicit <b>student_t_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; n0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_n</code> holds the value
  <code>n0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h2><code><a name="subtract_with_carry" id="subtract_with_carry">subtract_with_carry</a></code></h2>
  <pre>
template&lt;class IntType,
    IntType M, int S, int R&gt;
    class <b>subtract_with_carry</b> {
public:
    typedef IntType <b><a href="#subtract_with_carry::result_type">result_type</a></b>;
    static constexpr IntType <b><a href="#subtract_with_carry::modulus">modulus</a></b> = M;
    static constexpr int <b><a href="#subtract_with_carry::short_lag">short_lag</a></b> = S;
    static constexpr int <b><a href="#subtract_with_carry::long_lag">long_lag</a></b> = R;

    <b><a href="#subtract_with_carry::subtract_with_carry">subtract_with_carry</a></b>();
    explicit <b><a href="#subtract_with_carry::subtract_with_carry">subtract_with_carry</a></b>(IntType x0);
    template&lt;class Gen&gt;
        <b><a href="#subtract_with_carry::subtract_with_carry">subtract_with_carry</a></b>(Gen&amp; gen);
    void <b><a href="#subtract_with_carry::seed">seed</a></b>(IntType x0 = 19780503UL);
    template&lt;class Gen&gt;
        void <b><a href="#subtract_with_carry::seed">seed</a></b>(Gen&amp; gen);

    result_type <b><a href="#subtract_with_carry::min">min</a></b>() const;
    result_type <b><a href="#subtract_with_carry::max">max</a></b>() const;
    result_type <b><a href="#subtract_with_carry::operator()">operator()</a></b>();
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#simple%20engine">simple engine</a> that produces
  values of a user-specified integral type using the <b><a name=
  "subtract_with_carry::recurrence relation">recurrence relation</a></b> <code>x(i) = (x(i - R) - x(i - S) -
  cy(i - 1)) mod M</code>, where <code>cy(i)</code> has the value <code>1</code> if <code>x(i - S) - x(i - R)
  - cy(i - 1) &lt; 0</code>, otherwise <code>0</code>.</p>

  <p>The engine's <a href="lib_rand.html#state">state</a> is a carry indicator plus <code>R</code> values.
  These values consist of the last <code>R</code> values returned if <code>operator()</code> has been called
  at least <code>R</code> times, otherwise the <code>N</code> values that have been returned and the last
  <code>R - N</code> values of the <a href="lib_rand.html#seed%20function">seed</a>.</p>

  <p>The template argument <a href="lib_rand.html#IntType">IntType</a> must be large enough to hold values up
  to <code>M - 1</code>. The values of the template arguments <code>S</code> and <code>R</code> must be
  greater than 0 and <code>S</code> must be less than <code>R</code>.</p>

  <h3><code><a name="subtract_with_carry::long_lag" id=
  "subtract_with_carry::long_lag">subtract_with_carry::long_lag</a></code></h3>
  <pre>
static constexpr int <b>long_lag</b> = R;
</pre>

  <p>The static const variable holds the value of the template argument <code>R</code>.</p>

  <h3><code><a name="subtract_with_carry::max" id=
  "subtract_with_carry::max">subtract_with_carry::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns <code>M - 1</code>.</p>

  <h3><code><a name="subtract_with_carry::min" id=
  "subtract_with_carry::min">subtract_with_carry::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns zero.</p>

  <h3><code><a name="subtract_with_carry::modulus" id=
  "subtract_with_carry::modulus">subtract_with_carry::modulus</a></code></h3>
  <pre>
static constexpr IntType <b>modulus</b> = M;
</pre>

  <p>The static const variable holds the value of the template argument <code>M</code>.</p>

  <h3><code><a name="subtract_with_carry::operator()">subtract_with_carry::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function generates the next value in the pseudo-random sequence by applying the <a href=
  "#subtract_with_carry::recurrence%20relation">recurrence relation</a> to the stored historical values,
  stores the generated value, and returns it.</p>

  <h3><code><a name="subtract_with_carry::result_type" id=
  "subtract_with_carry::result_type">subtract_with_carry::result_type</a></code></h3>
  <pre>
typedef IntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h3><code><a name="subtract_with_carry::seed" id=
  "subtract_with_carry::seed">subtract_with_carry::seed</a></code></h3>
  <pre>
void <b>seed</b>(unsigned long x0 = 19780503UL);
template&lt;class Gen&gt;
    void <b>seed</b>(Gen&amp; gen);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0 &lt; x0</code></p>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> generates <code>long_lag</code>
  historical values from the values of type <code>unsigned long</code> returned by successive invocations of
  <code>gen</code>. Each historical value is <code>gen() % modulus</code>.</p>

  <p>The second seed function effectively executes the following code:</p>
  <pre>
    linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; gen(x0);
    seed(gen);
</pre>

  <h3><code><a name="subtract_with_carry::short_lag" id=
  "subtract_with_carry::short_lag">subtract_with_carry::short_lag</a></code></h3>
  <pre>
static constexpr int <b>short_lag</b> = S;
</pre>

  <p>The static const variable holds the value of the template argument <code>S</code>.</p>

  <h3><code><a name="subtract_with_carry::subtract_with_carry" id=
  "subtract_with_carry::subtract_with_carry">subtract_with_carry::subtract_with_carry</a></code></h3>
  <pre>
<b>subtract_with_carry</b>();
explicit <b>subtract_with_carry</b>(unsigned long x0);
template&lt;class Gen&gt;
    <b>subtract_with_carry</b>(Gen&amp; gen);
</pre>

  <p>The first constructor constructs an object and initializes it by calling <code>seed()</code>. The second
  constructor constructs an object and initializes it by calling <code>seed(x0)</code>. The third constructor
  constructs an object and initializes it by calling <code>seed(gen)</code>.</p>

  <h2><code><a name="subtract_with_carry_engine" id=
  "subtract_with_carry_engine">subtract_with_carry_engine</a></code></h2>
  <pre>
template&lt;class UIntType,
    int W, int S, int R&gt;
    class <b>subtract_with_carry_engine</b> { <b>[added with C++0X]</b>
public:
    typedef UIntType <b><a href="#subtract_with_carry_engine::result_type">result_type</a></b>;
    static constexpr int <b><a href="#subtract_with_carry_engine::word_size">word_size</a></b> = W;
    static constexpr int <b><a href="#subtract_with_carry_engine::short_lag">short_lag</a></b> = S;
    static constexpr int <b><a href="#subtract_with_carry_engine::long_lag">long_lag</a></b> = R;
    static constexpr UIntType <b><a href=
"#subtract_with_carry_engine::default_seed">default_seed</a></b> = 19780503U;

    explicit <b><a href=
"#subtract_with_carry_engine::subtract_with_carry_engine">subtract_with_carry_engine</a></b>(UIntType x0 = default_seed);
    explicit <b><a href=
"#subtract_with_carry_engine::subtract_with_carry_engine">subtract_with_carry_engine</a></b>(seed_seq&amp; seq);
    void <b><a href="#subtract_with_carry_engine::seed">seed</a></b>(UIntType x0 = default_seed);
    void <b><a href="#subtract_with_carry_engine::seed">seed</a></b>(seed_seq&amp; seq);

    static constexpr result_type <b><a href="#subtract_with_carry_engine::min">min</a></b>();
    static constexpr result_type <b><a href="#subtract_with_carry_engine::max">max</a></b>();
    result_type <b><a href="#subtract_with_carry_engine::operator()">operator()</a></b>();
    void <b><a href="#subtract_with_carry_engine::discard">discard</a></b>(unsigned long long count)();
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#simple%20engine">simple engine</a> that produces
  values of a user-specified unsigned integral type using the <b><a name=
  "subtract_with_carry_engine::recurrence relation">recurrence relation</a></b> <code>x(i) = (x(i - R) - x(i
  - S) - cy(i - 1)) mod M</code>, where <code>cy(i)</code> has the value <code>1</code> if <code>x(i - S) -
  x(i - R) - cy(i - 1) &lt; 0</code>, otherwise <code>0</code>, and <code>M</code> has the value
  <code>2<sup>W</sup></code>. (Note that the template parameter <code>W</code> here replaces the template
  parameter <code>M</code> for <code><a href="#subtract_with_carry">subtract_with_carry</a></code>.) The
  engine's <a href="lib_rand.html#state">state</a> is a carry indicator plus <code>R</code> values. These
  values consist of the last <code>R</code> values returned if <code>operator()</code> has been called at
  least <code>R</code> times, otherwise the <code>N</code> values that have been returned and the last
  <code>R - N</code> values of the <a href="lib_rand.html#seed%20function">seed</a>.</p>

  <p>The template argument <a href="lib_rand.html#UIntType">UIntType</a> must be large enough to hold values
  up to <code>M - 1</code>. The values of the template arguments <code>S</code> and <code>R</code> must be
  greater than 0 and <code>S</code> must be less than <code>R</code>.</p>

  <h3><code><a name="subtract_with_carry_engine::default_seed" id=
  "subtract_with_carry_engine::default_seed">subtract_with_carry_engine::default_seed</a></code></h3>
  <pre>
static constexpr UIntType <b>default_seed</b> = 19780503U;
</pre>

  <p>The static const variable holds the default seed value <code>19780503U</code>.</p>

  <h3><code><a name="subtract_with_carry_engine::discard" id=
  "subtract_with_carry_engine::discard">subtract_with_carry_engine::discard</a></code></h3>
  <pre>
void <b>discard</b>(unsigned long long count);
</pre>

  <p>The member function effectively calls <code>(*this)()</code> <code>count</code> times.</p>

  <h3><code><a name="subtract_with_carry_engine::long_lag" id=
  "subtract_with_carry_engine::long_lag">subtract_with_carry_engine::long_lag</a></code></h3>
  <pre>
static constexpr int <b>long_lag</b> = R;
</pre>

  <p>The static const variable holds the value of the template argument <code>R</code>.</p>

  <h3><code><a name="subtract_with_carry_engine::max" id=
  "subtract_with_carry_engine::max">subtract_with_carry_engine::max</a></code></h3>
  <pre>
static constexpr result_type <b>max</b>();
</pre>

  <p>The member function returns <code>M - 1</code>.</p>

  <h3><code><a name="subtract_with_carry_engine::min" id=
  "subtract_with_carry_engine::min">subtract_with_carry_engine::min</a></code></h3>
  <pre>
static constexpr result_type <b>min</b>();
</pre>

  <p>The member function returns zero.</p>

  <h3><code><a name=
  "subtract_with_carry_engine::operator()">subtract_with_carry_engine::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function generates the next value in the pseudo-random sequence by applying the <a href=
  "#subtract_with_carry_engine::recurrence%20relation">recurrence relation</a> to the stored historical
  values, stores the generated value, and returns it.</p>

  <h3><code><a name="subtract_with_carry_engine::result_type" id=
  "subtract_with_carry_engine::result_type">subtract_with_carry_engine::result_type</a></code></h3>
  <pre>
typedef UIntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>UIntType</code>.</p>

  <h3><code><a name="subtract_with_carry_engine::seed" id=
  "subtract_with_carry_engine::seed">subtract_with_carry_engine::seed</a></code></h3>
  <pre>
void <b>seed</b>(UIntType x0 = default_seed);
void <b>seed</b>(seed_seq&amp; seq);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0 &lt; x0</code></p>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> effectively constructs the engine
  <code>gen</code>:</p>
  <pre>
linear_congruential_engine&lt;UIntType, 40014, 0, 2147483563&gt;
    gen(x0 == 0 ? default_seed: x0);
</pre>

  <p>It then sets the <code>R</code> historical values beginning with <code>h[0]</code> to the values
  produced by calling <code>gen()</code>.</p>

  <p>The second seed function sets these historical values as follows:</p>

  <ul>
    <li><code>k</code> is the number of <i>unsigned long</i> integers needed to supply all the bits in a
    <code>UIntType</code> integer (at least 1).</li>

    <li><code>a</code> is an array of <code>R * k</code> elements of type <code>UIntType</code>.</li>

    <li><code>a</code> is initialized by calling <code>seq.generate(&amp;a[0], &amp;a[R * k])</code>.</li>

    <li>Each <code>h[i]</code> is composed by packing the <code>k</code> elements beginning at <code>a[i *
    k]</code>, which supplies the lowest-order bits.</li>

    <li>Each <code>h[i]</code> is reduced modulo <code>M</code>.</li>
  </ul>

  <p>In either case, the stored carry is <code>h[R - 1] == 0</code>.</p>

  <h3><code><a name="subtract_with_carry_engine::short_lag" id=
  "subtract_with_carry_engine::short_lag">subtract_with_carry_engine::short_lag</a></code></h3>
  <pre>
static constexpr int <b>short_lag</b> = S;
</pre>

  <p>The static const variable holds the value of the template argument <code>S</code>.</p>

  <h3><code><a name="subtract_with_carry_engine::subtract_with_carry_engine" id=
  "subtract_with_carry_engine::subtract_with_carry_engine">subtract_with_carry_engine::subtract_with_carry_engine</a></code></h3>
  <pre>
explicit <b>subtract_with_carry_engine</b>(UIntType x0 = default_seed);
<b>subtract_with_carry_engine</b>(seed_seq&amp; seq);
</pre>

  <p>The first constructor constructs an object and initializes it by calling <code>seed(x0)</code>. The
  secibd constructor constructs an object and initializes it by calling <code>seed(seq)</code>.</p>

  <h3><code><a name="subtract_with_carry_engine::word_size" id=
  "subtract_with_carry_engine::word_size">subtract_with_carry_engine::word_size</a></code></h3>
  <pre>
static constexpr int <b>word_size</b> = W;
</pre>

  <p>The static const variable holds the value of the template argument <code>W</code>.</p>

  <h2><code><a name="subtract_with_carry_01" id=
  "subtract_with_carry_01">subtract_with_carry_01</a></code></h2>
  <pre>
template&lt;class RealType,
    int W, int S, int R&gt;
    class <b>subtract_with_carry_01</b> {
public:
    typedef RealType <b><a href="#subtract_with_carry_01::result_type">result_type</a></b>;
    static constexpr int <b><a href="#subtract_with_carry_01::word_size">word_size</a></b> = W;
    static constexpr int <b><a href="#subtract_with_carry_01::short_lag">short_lag</a></b> = S;
    static constexpr int <b><a href="#subtract_with_carry_01::long_lag">long_lag</a></b> = R;

    <b><a href="#subtract_with_carry_01::subtract_with_carry_01">subtract_with_carry_01</a></b>();
    explicit <b><a href=
"#subtract_with_carry_01::subtract_with_carry_01">subtract_with_carry_01</a></b>(unsigned long x0);
    template&lt;class Gen&gt;
        <b><a href=
"#subtract_with_carry_01::subtract_with_carry_01">subtract_with_carry_01</a></b>(Gen&amp; gen);
    void <b><a href="#subtract_with_carry_01::seed">seed</a></b>(unsigned long x0 = 19780503UL);
    template&lt;class Gen&gt;
        void <b><a href="#subtract_with_carry_01::seed">seed</a></b>(Gen&amp; gen);

    result_type <b><a href="#subtract_with_carry_01::min">min</a></b>() const;
    result_type <b><a href="#subtract_with_carry_01::max">max</a></b>() const;
    result_type <b><a href="#subtract_with_carry_01::operator()">operator()</a></b>();
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#simple%20engine">simple engine</a> that produces
  values of a user-specified floating-point type using the <b><a name=
  "subtract_with_carry_01::recurrence relation">recurrence relation</a></b> <code>x(i) = (x(i - R) - x(i - S)
  - cy(i - 1)) mod 1</code>, where <code>cy(i)</code> has the value <code>2<sup>-W</sup></code> if <code>x(i
  - S) - x(i - R) - cy(i - 1) &lt; 0</code>, otherwise <code>0</code>. The engine's <a href=
  "lib_rand.html#state">state</a> is the last <code>R</code> values returned if <code>operator()</code> has
  been called at least <code>R</code> times, otherwise the <code>M</code> values that have been returned and
  the last <code>R - M</code> values of the <a href="lib_rand.html#seed%20function">seed</a>.</p>

  <p>The template argument <a href="lib_rand.html#RealType">RealType</a> must be large enough to hold values
  with <code>W</code> fraction bits. The values of the template arguments <code>S</code> and <code>R</code>
  must be greater than 0 and <code>S</code> must be less than <code>R</code>.</p>

  <h3><code><a name="subtract_with_carry_01::long_lag" id=
  "subtract_with_carry_01::long_lag">subtract_with_carry_01::long_lag</a></code></h3>
  <pre>
static constexpr int <b>long_lag</b> = R;
</pre>

  <p>The static const variable holds the value of the template argument <code>R</code>.</p>

  <h3><code><a name="subtract_with_carry_01::max" id=
  "subtract_with_carry_01::max">subtract_with_carry_01::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value in the generated sequence.</p>

  <h3><code><a name="subtract_with_carry_01::min" id=
  "subtract_with_carry_01::min">subtract_with_carry_01::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns zero.</p>

  <h3><code><a name="subtract_with_carry_01::operator()">subtract_with_carry_01::operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member function generates the next value in the pseudo-random sequence by applying the <a href=
  "#subtract_with_carry::recurrence%20relation">recurrence relation</a> to the stored historical values,
  stores the generated value, and returns it.</p>

  <h3><code><a name="subtract_with_carry_01::result_type" id=
  "subtract_with_carry_01::result_type">subtract_with_carry01::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="subtract_with_carry_01::seed" id=
  "subtract_with_carry_01::seed">subtract_with_carry_01::seed</a></code></h3>
  <pre>
template&lt;class Gen&gt;
    void <b>seed</b>(Gen&amp; gen);
void <b>seed</b>(unsigned long x0 = 19780503UL);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0 &lt; x0</code></p>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> generates <code>long_lag</code>
  historical values from the values of type <code>unsigned long</code> returned by successive invocations of
  <code>gen</code>. Each historical value is generated by concatenating the low 32 bits from each of
  <code>long_lag * (word_size + 31) / 32</code> values from the initialization sequence; the resulting value
  is then divided by <code>2.0<sup>word_size</sup></code> and the integral part discarded. Thus, each
  historical value is a floating-point value greater than or equal to 0.0 and less than 1.0, with
  <code>word_size</code> significant bits.</p>

  <p>The second seed function effectively executes the following code:</p>
  <pre>
    linear_congruential&lt;unsigned long, 40014, 0, 2147483563&gt; gen(x0);
    seed(gen);
</pre>

  <h3><code><a name="subtract_with_carry_01::short_lag" id=
  "subtract_with_carry_01::short_lag">subtract_with_carry_01::short_lag</a></code></h3>
  <pre>
static constexpr int <b>short_lag</b> = S;
</pre>

  <p>The static const variable holds the value of the template argument <code>S</code>.</p>

  <h3><code><a name="subtract_with_carry_01::subtract_with_carry_01" id=
  "subtract_with_carry_01::subtract_with_carry_01">subtract_with_carry_01::subtract_with_carry_01</a></code></h3>
  <pre>
<b>subtract_with_carry_01</b>();
explicit <b>subtract_with_carry_01</b>(IntType x0);
template&lt;class In&gt;
    <b>subtract_with_carry_01</b>(InIt&amp; first, InIt last);
</pre>

  <p>The first constructor constructs an object and initializes it by calling <code>seed()</code>. The second
  constructor constructs an object and initializes it by calling <code>seed(x0)</code>. The third constructor
  constructs an object and initializes it by calling <code>seed(first, last)</code>.</p>

  <h3><code><a name="subtract_with_carry_01::word_size" id=
  "subtract_with_carry_01::word_size">subtract_with_carry_01::word_size</a></code></h3>
  <pre>
static constexpr int <b>word_size</b> = W;
</pre>

  <p>The static const variable holds the value of the template argument <code>W</code>.</p>

  <h2><code><a name="uniform_int" id="uniform_int">uniform_int</a></code></h2>
  <pre>
template&lt;class IntType = int&gt;
    class <b>uniform_int</b> {
public:
    typedef IntType <b><a href="#uniform_int::input_type">input_type</a></b>;
    typedef IntType <b><a href="#uniform_int::result_type">result_type</a></b>;

    explicit <b><a href="#uniform_int::uniform_int">uniform_int</a></b>(result_type min0 = 0,
        result_type max0 = 9);

    result_type <b><a href="#uniform_int::min">min</a></b>() const;
    result_type <b><a href="#uniform_int::max">max</a></b>() const;
    void <b><a href="#uniform_int::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#uniform_int::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#uniform_int::operator()">operator()</a></b>(Engine&amp; eng, result_type n);

private:
    result_type stored_min;    <i>// exposition only</i>
    result_type stored_max;    <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified integral type with a uniform distribution.</p>

  <h3><code><a name="uniform_int::input_type" id=
  "uniform_int::input_type">uniform_int::input_type</a></code></h3>
  <pre>
typedef IntType <b>input_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h3><code><a name="uniform_int::max" id="uniform_int::max">uniform_int::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns <code>stored_max</code>.</p>

  <h3><code><a name="uniform_int::min" id="uniform_int::min">uniform_int::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns <code>stored_min</code>.</p>

  <h3><code><a name="uniform_int::operator()">uniform_int::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng, result_type n);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed integral values and returns integral values with each value <code>i</code>
  in the closed range <code>[min(), max()]</code> occurring with equal probability and values outside that
  range occurring with probability 0.</p>

  <p>The second member function uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed integral values and returns integral values with each value <code>i</code>
  in the half-open range <code>[0, n)</code> occurring with equal probability and values outside that range
  occurring with probability 0.</p>

  <h3><code><a name="uniform_int::reset" id="uniform_int::reset">uniform_int::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="uniform_int::result_type" id=
  "uniform_int::result_type">uniform_int::result_type</a></code></h3>
  <pre>
typedef IntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h3><code><a name="uniform_int::uniform_int" id=
  "uniform_int::uniform_int">uniform_int::uniform_int</a></code></h3>
  <pre>
explicit <b>uniform_int</b>(result_type min0 = 0, result_type max0 = 9);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>min0 &lt; max0</code></p>

  <p>The constructor constructs an object whose stored value <code>stored_min</code> holds the value
  <code>min0</code> and whose stored value <code>stored_max</code> holds the value <code>max0</code>.</p>

  <h2><code><a name="uniform_int_distribution" id=
  "uniform_int_distribution">uniform_int_distribution</a></code></h2>
  <pre>
template&lt;class IntType = int&gt;
    class <b>uniform_int_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef IntType <b><a href="#uniform_int_distribution::result_type">result_type</a></b>;
    struct <b><a href="#uniform_int_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#uniform_int_distribution::uniform_int_distribution">uniform_int_distribution</a></b>(result_type min0 = 0,
        result_type max0 = std::numeric_limits&lt;IntType&gt;::max());
    explicit <b><a href=
"#uniform_int_distribution::uniform_int_distribution">uniform_int_distribution</a></b>(const param_type&amp; par0);

    result_type <b><a href="#uniform_int_distribution::a">a</a></b>() const;
    result_type <b><a href="#uniform_int_distribution::b">b</a></b>() const;
    param_type <b><a href="#uniform_int_distribution::param">param</a></b>() const;
    void <b><a href="#uniform_int_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#uniform_int_distribution::min">min</a></b>() const;
    result_type <b><a href="#uniform_int_distribution::max">max</a></b>() const;
    void <b><a href="#uniform_int_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#uniform_int_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#uniform_int_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type stored_min;    <i>// exposition only</i>
    result_type stored_max;    <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified integral type with a uniform distribution.</p>

  <h3><code><a name="uniform_int_distribution::a" id=
  "uniform_int_distribution::a">uniform_int_distribution::a</a></code></h3>
  <pre>
result_type <b>a</b>() const;
</pre>

  <p>The member function returns the parameter <code>stored_max</code>.</p>

  <h3><code><a name="uniform_int_distribution::b" id=
  "uniform_int_distribution::b">uniform_int_distribution::b</a></code></h3>
  <pre>
result_type <b>b</b>() const;
</pre>

  <p>The member function returns the parameter <code>stored_min</code>.</p>

  <h3><code><a name="uniform_int_distribution::max" id=
  "uniform_int_distribution::max">uniform_int_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns <code>stored_max</code>.</p>

  <h3><code><a name="uniform_int_distribution::min" id=
  "uniform_int_distribution::min">uniform_int_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns <code>stored_min</code>.</p>

  <h3><code><a name=
  "uniform_int_distribution::operator()">uniform_int_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed integral values and returns integral values with each value <code>i</code>
  in the closed range <code>[min(), max()]</code> occurring with equal probability and values outside that
  range occurring with probability 0.</p>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="uniform_int_distribution::param" id=
  "uniform_int_distribution::param">uniform_int_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="uniform_int_distribution::param_type" id=
  "uniform_int_distribution::param_type">uniform_int_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef uniform_int_distribution&lt;IntType&gt; distribution_type;

    param_type(result_type a0 = 0,
        result_type b0 = std::numeric_limits&lt;IntType&gt;::max());
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="uniform_int_distribution::reset" id=
  "uniform_int_distribution::reset">uniform_int_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="uniform_int_distribution::result_type" id=
  "uniform_int_distribution::result_type">uniform_int_distribution::result_type</a></code></h3>
  <pre>
typedef IntType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>IntType</code>.</p>

  <h3><code><a name="uniform_int_distribution::uniform_int_distribution" id=
  "uniform_int_distribution::uniform_int_distribution">uniform_int_distribution::uniform_int_distribution</a></code></h3>
  <pre>
explicit <b>uniform_int_distribution</b>(result_type min0 = 0,
    result_type max0 = std::numeric_limits&lt;IntType&gt;::max());
explicit <b>uniform_int_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>min0 &lt; max0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_min</code> holds the value
  <code>min0</code> and whose stored value <code>stored_max</code> holds the value <code>max0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h2><code><a name="uniform_real" id="uniform_real">uniform_real</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>uniform_real</b> {
public:
    typedef RealType <b><a href="#uniform_real::input_type">input_type</a></b>;
    typedef RealType <b><a href="#uniform_real::result_type">result_type</a></b>;

    explicit <b><a href="#uniform_real::uniform_real">uniform_real</a></b>(result_type min0 = result_type(0),
        result_type max0 = result_type(1));

    result_type <b><a href="#uniform_real::min">min</a></b>() const;
    result_type <b><a href="#uniform_real::max">max</a></b>() const;
    void <b><a href="#uniform_real::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#uniform_real::operator()">operator()</a></b>(Engine&amp; eng);

private:
    result_type stored_min;    <i>// exposition only</i>
    result_type stored_max;    <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type with a uniform distribution.</p>

  <h3><code><a name="uniform_real::input_type" id=
  "uniform_real::input_type">uniform_real::input_type</a></code></h3>
  <pre>
typedef RealType <b>input_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="uniform_real::max" id="uniform_real::max">uniform_real::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns <code>stored_max</code>.</p>

  <h3><code><a name="uniform_real::min" id="uniform_real::min">uniform_real::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns <code>stored_min</code>.</p>

  <h3><code><a name="uniform_real::operator()">uniform_real::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
</pre>

  <p>The member function uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a source of
  uniformly distributed floating-point values and returns floating-point values with each value
  <code>x</code> in the half-open range <code>[min(), max())</code> occurring with equal probability, and
  values outside that range occurring with probability 0.</p>

  <h3><code><a name="uniform_real::reset" id="uniform_real::reset">uniform_real::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="uniform_real::result_type" id=
  "uniform_real::result_type">uniform_real::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="uniform_real::uniform_real" id=
  "uniform_real::uniform_real">uniform_real::uniform_real</a></code></h3>
  <pre>
explicit <b>uniform_real</b>(result_type min0 = result_type(0),
    result_type max0 = result_type(1));
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>min0 &lt; max0</code></p>

  <p>The constructor constructs an object whose stored value <code>stored_min</code> holds the value
  <code>min0</code> and whose stored value <code>stored_max</code> holds the value <code>max0</code>.</p>

  <h2><code><a name="uniform_real_distribution" id=
  "uniform_real_distribution">uniform_real_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>uniform_real_distribution</b> {
public:
    typedef RealType <b><a href="#uniform_real_distribution::result_type">result_type</a></b>;
    struct <b><a href="#uniform_real_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#uniform_real_distribution::uniform_real_distribution">uniform_real_distribution</a></b>(result_type min0 = result_type(0.0),
        result_type max0 = result_type(1.0));
    explicit <b><a href=
"#uniform_real_distribution::uniform_real_distribution">uniform_real_distribution</a></b>(const param_type&amp; par0);

    result_type <b><a href="#uniform_real_distribution::a">a</a></b>() const;
    result_type <b><a href="#uniform_real_distribution::b">b</a></b>() const;
    param_type <b><a href="#uniform_real_distribution::param">param</a></b>() const;
    void <b><a href="#uniform_real_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#uniform_real_distribution::min">min</a></b>() const;
    result_type <b><a href="#uniform_real_distribution::max">max</a></b>() const;
    void <b><a href="#uniform_real_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#uniform_real_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#uniform_real_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type stored_min;    <i>// exposition only</i>
    result_type stored_max;    <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type with a uniform distribution.</p>

  <h3><code><a name="uniform_real_distribution::a" id=
  "uniform_real_distribution::a">uniform_real_distribution::a</a></code></h3>
  <pre>
result_type <b>a</b>() const;
</pre>

  <p>The member function returns the parameter <code>stored_max</code>.</p>

  <h3><code><a name="uniform_real_distribution::b" id=
  "uniform_real_distribution::b">uniform_real_distribution::b</a></code></h3>
  <pre>
result_type <b>b</b>() const;
</pre>

  <p>The member function returns the parameter <code>stored_min</code>.</p>

  <h3><code><a name="uniform_real_distribution::max" id=
  "uniform_real_distribution::max">uniform_real_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns <code>stored_max</code>.</p>

  <h3><code><a name="uniform_real_distribution::min" id=
  "uniform_real_distribution::min">uniform_real_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns <code>stored_min</code>.</p>

  <h3><code><a name=
  "uniform_real_distribution::operator()">uniform_real_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The member function uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a source of
  uniformly distributed floating-point values and returns floating-point values with each value
  <code>x</code> in the half-open range <code>[min(), max())</code> occurring with equal probability, and
  values outside that range occurring with probability 0.</p>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="uniform_real_distribution::param" id=
  "uniform_real_distribution::param">uniform_real_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="uniform_real_distribution::param_type" id=
  "uniform_real_distribution::param_type">uniform_real_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef uniform_real_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(0.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="uniform_real_distribution::reset" id=
  "uniform_real_distribution::reset">uniform_real_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="uniform_real_distribution::result_type" id=
  "uniform_real_distribution::result_type">uniform_real_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="uniform_real_distribution::uniform_real_distribution" id=
  "uniform_real_distribution::uniform_real_distribution">uniform_real_distribution::uniform_real_distribution</a></code></h3>
  <pre>
explicit <b>uniform_real_distribution</b>(result_type min0 = result_type(0.0),
    result_type max0 = result_type(1.0));
explicit <b>uniform_real_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>min0 &lt; max0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_min</code> holds the value
  <code>min0</code> and whose stored value <code>stored_max</code> holds the value <code>max0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h2><code><a name="variate_generator" id="variate_generator">variate_generator</a></code></h2>
  <pre>
template&lt;class Engine, class Dist&gt;
    class <b>variate_generator</b> {
public:
    typedef Engine <b><a href="#variate_generator::engine_type">engine_type</a></b>;
    typedef <i>engine-return-type</i> <b><a href=
"#variate_generator::engine_value_type">engine_value_type</a></b>;
    typedef Dist <b><a href="#variate_generator::distribution_type">distribution_type</a></b>;
    typedef typename Dist::result_type <b><a href="#variate_generator::result_type">result_type</a></b>;

    <b><a href=
"#variate_generator::variate_generator">variate_generator</a></b>(engine_type eng0, distribution_type dist0);

    result_type <b><a href="#variate_generator::operator()">operator()</a></b>();
    template&lt;class T&gt;
        result_type <b><a href="#variate_generator::operator()">operator()</a></b>(T value);
    engine_value_type&amp; <b><a href="#variate_generator::engine">engine</a></b>();
    const engine_value_type&amp; <b><a href="#variate_generator::engine">engine</a></b>() const;
    distribution_type&amp; <b><a href="#variate_generator::distribution">distribution</a></b>();
    const distribution_type&amp; <b><a href="#variate_generator::distribution">distribution</a></b>() const;
    result_type <b><a href="#variate_generator::min">min</a></b>() const;
    result_type <b><a href="#variate_generator::max">max</a></b>() const;

private:
    Engine eng;             <i>// exposition only</i>
    Dist dist;              <i>// exposition only</i>
    };
</pre>

  <p>The template class describes an object that holds an <a href="lib_rand.html#engine">engine</a> and a
  <a href="lib_rand.html#distribution">distribution</a> and produces values by passing the <a href=
  "#wrapped%20engine">wrapped engine</a> object to the <code>distribution</code> object's
  <code>operator()</code>.</p>

  <p>The template argument <code>Engine</code> can be a type <code>Eng</code>, <code>Eng*</code>, or
  <code>Eng&amp;</code>, where <code>Eng</code> is an <a href="lib_rand.html#engine">engine</a>. The type
  <code>Eng</code> is the <b><a name="underlying engine type">underlying engine type</a></b>. The
  corresponding object of type <code>Eng</code> is the the <b><a name="underlying engine object">underlying
  engine object</a></b>.</p>

  <p>The template uses a <b><a name="wrapped engine">wrapped engine</a></b> to match the type of the values
  produced by the <code>engine</code> object to the type of values required by the <code>distribution</code>
  object. The wrapped engine's <code>operator()</code> returns values of type <code>Dist::input_type</code>,
  generated as follows:</p>

  <ul>
    <li>if <code>Engine::result_type</code> and <code>Dist::input_type</code> are both integral types it
    returns <code>eng()</code>, converted to type <code>Dist::input_type</code>.</li>

    <li>if <code>Engine::result_type</code> and <code>Dist::input_type</code> are both floating-point types
    it returns <code>(eng() - eng.min()) / (eng.max() - eng.min())</code>, converted to type
    <code>Dist::input_type</code>.</li>

    <li>if <code>Engine::result_type</code> is an integral type and <code>Dist::input_type</code> is a
    floating-point type it returns <code>(eng() - eng.min()) / (eng.max() - eng.min() + 1)</code>, converted
    to type <code>Dist::input_type</code>.</li>

    <li>if <code>Engine::result_type</code> is a floating-point type and <code>Dist::input_type</code> is an
    integral type it returns <code>((eng() - eng.min()) / (eng.max() - eng.min()) *
    std::numeric_limits&lt;Dist::input_type&gt;::max()</code>, converted to type
    <code>Dist::input_type</code>.</li>
  </ul>

  <h3><code><a name="variate_generator::distribution" id=
  "variate_generator::distribution">variate_generator::distribution</a></code></h3>
  <pre>
distribution_type&amp; <b>distribution</b>();
const distribution_type&amp; <b>distribution</b>() const;
</pre>

  <p>The member functions return a reference to the stored distribution object <code>dist</code>.</p>

  <h3><code><a name="variate_generator::distribution_type" id=
  "variate_generator::distribution_type">variate_generator::distribution_type</a></code></h3>
  <pre>
typedef Dist <b>distribution_type</b>;
</pre>

  <p>The type is a synonym for the template parameter <code>Dist</code>.</p>

  <h3><code><a name="variate_generator::engine" id=
  "variate_generator::engine">variate_generator::engine</a></code></h3>
  <pre>
engine_value_type <b>engine()</b>;
const engine_value_type&amp; <b>engine</b>() const;
</pre>

  <p>The member functions return a reference to the <a href="#underlying%20engine%20object">underlying engine
  object</a>.</p>

  <h3><code><a name="variate_generator::engine_type" id=
  "variate_generator::engine_type">variate_generator::engine_type</a></code></h3>
  <pre>
typedef Engine <b>engine_type</b>;
</pre>

  <p>The type is a synonym for the template parameter <code>Engine</code>.</p>

  <h3><code><a name="variate_generator::engine_value_type" id=
  "variate_generator::engine_value_type">variate_generator::engine_value_type</a></code></h3>
  <pre>
typedef <i>engine-value-type</i> <b>engine_value_type</b>;
</pre>

  <p>The type is a synonym for the type of values returned by the <a href=
  "#underlying%20engine%20type">underlying engine type</a>.</p>

  <h3><code><a name="variate_generator::max" id=
  "variate_generator::max">variate_generator::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns <code>dist.max()</code>.</p>

  <h3><code><a name="variate_generator::min" id=
  "variate_generator::min">variate_generator::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns <code>dist.min()</code>.</p>

  <h3><code><a name="variate_generator::operator()">variate_generator::operator()</a></code></h3>
  <pre>
result_type <b>operator</b>()();
template&lt;class T&gt;
    result_type <b>operator</b>()(T value);
</pre>

  <p>The first member operator returns <code>dist(wr_eng)</code>, where <code>wr_eng</code> is the object's
  <a href="#wrapped%20engine">wrapped engine</a>.</p>

  <p>The second member function returns <code>dist(wr_eng, value)</code>, where <code>wr_eng</code> is the
  object's <a href="#wrapped%20engine">wrapped engine</a>.</p>

  <h3><code><a name="variate_generator::result_type" id=
  "variate_generator::result_type">variate_generator::result_type</a></code></h3>
  <pre>
typedef typename Dist::result_type <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>Dist::result_type</code>.</p>

  <h3><code><a name="variate_generator::variate_generator" id=
  "variate_generator::variate_generator">variate_generator::variate_generator</a></code></h3>
  <pre>
<b>variate_generator</b>(engine_type eng0, distribution_type dist0);
</pre>

  <p>The constructor constructs an object whose stored value <code>eng</code> holds <code>eng0</code> and
  whose stored value <code>dist</code> holds <code>dist0</code>.</p>

  <h2><code><a name="weibull_distribution" id="weibull_distribution">weibull_distribution</a></code></h2>
  <pre>
template&lt;class RealType = double&gt;
    class <b>weibull_distribution</b> { <b>[added with C++0X]</b>
public:
    typedef RealType <b><a href="#weibull_distribution::result_type">result_type</a></b>;
    struct <b><a href="#weibull_distribution::param_type">param_type</a></b>;

    explicit <b><a href=
"#weibull_distribution::weibull_distribution">weibull_distribution</a></b>(result_type a0 = result_type(1.0),
        result_type b0 = result_type(1.0));
    explicit <b><a href=
"#weibull_distribution::weibull_distribution">weibull_distribution</a></b>(const param_type&amp; par0);

    result_type <b><a href="#weibull_distribution::a">a</a></b>() const;
    result_type <b><a href="#weibull_distribution::b">b</a></b>() const;
    param_type <b><a href="#weibull_distribution::param">param</a></b>() const;
    void <b><a href="#weibull_distribution::param">param</a></b>(const param_type&amp; par0);

    result_type <b><a href="#weibull_distribution::min">min</a></b>() const;
    result_type <b><a href="#weibull_distribution::max">max</a></b>() const;
    void <b><a href="#weibull_distribution::reset">reset</a></b>();
    template&lt;class Engine&gt;
        result_type <b><a href="#weibull_distribution::operator()">operator()</a></b>(Engine&amp; eng);
    template&lt;class Engine&gt;
        result_type <b><a href="#weibull_distribution::operator()">operator()</a></b>(Engine&amp; eng,
            const param_type&amp; par0);

private:
    result_type <b>stored_a</b>;  <i>// exposition only</i>
    result_type <b>stored_b</b>;  <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#distribution">distribution</a> that produces values
  of a user-specified floating-point type distributed with a Weibull distribution.</p>

  <h3><code><a name="weibull_distribution::a" id=
  "weibull_distribution::a">weibull_distribution::a</a></code></h3>
  <pre>
result_type <b>a</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_a</code>.</p>

  <h3><code><a name="weibull_distribution::b" id=
  "weibull_distribution::b">weibull_distribution::b</a></code></h3>
  <pre>
result_type <b>b</b>() const;
</pre>

  <p>The member function returns the stored value <code>stored_b</code>.</p>

  <h3><code><a name="weibull_distribution::max" id=
  "weibull_distribution::max">weibull_distribution::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="weibull_distribution::min" id=
  "weibull_distribution::min">weibull_distribution::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value returnable by <code>operator()</code>.</p>

  <h3><code><a name="weibull_distribution::operator()">weibull_distribution::operator()</a></code></h3>
  <pre>
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng);
template&lt;class Engine&gt;
    result_type <b>operator()</b>(Engine&amp; eng,
        const param_type&amp; par0);
</pre>

  <p>The first member operator uses the <a href="lib_rand.html#engine">engine</a> <code>eng</code> as a
  source of uniformly distributed random integral values and returns floating-point values with each value
  <code>x</code> occurring with probability:</p>
  <pre>
    <img src="weibull_distribution.gif">
</pre>

  <p>The second member function behaves the same, except that it uses the parameters stored in
  <code>par0</code>.</p>

  <h3><code><a name="weibull_distribution::param" id=
  "weibull_distribution::param">weibull_distribution::param</a></code></h3>
  <pre>
param_type <b>param</b>() const;
void <b>param</b>(const param_type&amp; par0);
</pre>

  <p>The first member function returns and object that stores all the parameters of the distribution. The
  second member function initializes all the parameters from <code>par0</code>.</p>

  <h3><code><a name="weibull_distribution::param_type" id=
  "weibull_distribution::param_type">weibull_distribution::param_type</a></code></h3>
  <pre>
struct <b>param_type</b> {
    typedef weibull_distribution&lt;RealType&gt; distribution_type;

    param_type(result_type a0 = result_type(1.0),
        result_type b0 = result_type(1.0));
    result_type a() const;
    result_type b() const;
    .....
    bool operator==(const param_type&amp; right) const;
    bool operator!=(const param_type&amp; right) const;
    };
</pre>

  <p>The type is a class that can store all the parameters of the distribution.</p>

  <h3><code><a name="weibull_distribution::reset" id=
  "weibull_distribution::reset">weibull_distribution::reset</a></code></h3>
  <pre>
void <b>reset</b>();
</pre>

  <p>The member function discards any stored values in the generated sequence.</p>

  <h3><code><a name="weibull_distribution::result_type" id=
  "weibull_distribution::result_type">weibull_distribution::result_type</a></code></h3>
  <pre>
typedef RealType <b>result_type</b>;
</pre>

  <p>The type is a synonym for <code>RealType</code>.</p>

  <h3><code><a name="weibull_distribution::weibull_distribution" id=
  "weibull_distribution::weibull_distribution">weibull_distribution::weibull_distribution</a></code></h3>
  <pre>
<b>weibull_distribution</b>(result_type a0 = result_type(1.0),
    result_type b0 = result_type(1.0));
explicit <b>weibull_distribution</b>(const param_type&amp; par0);
</pre>

  <p><a href="lib_rand.html#Precondition">Precondition:</a> <code>0.0 &lt; a0 &amp;&amp; 0.0 &lt;
  b0</code></p>

  <p>The first constructor constructs an object whose stored value <code>stored_a</code> holds the value
  <code>a0</code> and whose stored value <code>stored_b</code> holds the value <code>b0</code>.</p>

  <p>The second constructor constructs an object whose stored parameters are initialized from
  <code>par0</code>.</p>

  <h2><code><a name="xor_combine" id="xor_combine">xor_combine</a></code></h2>
  <pre>
template&lt;class Engine1, int S1,
    class Engine2, int S2&gt;
    class <b>xor_combine</b> { <b>[removed with C++0X]</b>
public:
    typedef Engine1 <b><a href="#xor_combine::base1_type">base1_type</a></b>;
    typedef Engine2 <b><a href="#xor_combine::base2_type">base2_type</a></b>;
    typedef T1 <b><a href="#xor_combine::result_type">result_type</a></b>;

    static constexpr int <b><a href="#xor_combine::shift1">shift1</a></b> = S1;
    static constexpr int <b><a href="#xor_combine::shift2">shift2</a></b> = S2;

    <b><a href="#xor_combine::xor_combine">xor_combine</a></b>();
    <b><a href="#xor_combine::xor_combine">xor_combine</a></b>(result_type x0);
    <b><a href=
"#xor_combine::xor_combine">xor_combine</a></b>(const base1_type&amp; eng1, const base2_type&amp; eng2);
    template&lt;class Gen&gt;
        <b><a href="#xor_combine::xor_combine">xor_combine</a></b>(Gen&amp; gen);
    void <b><a href="#xor_combine::seed">seed</a></b>();
    template&lt;class Gen&gt;
        void <b><a href="#xor_combine::seed">seed</a></b>(Gen&amp; gen);

    const base1_type&amp; <b><a href="#xor_combine::base1">base1</a></b>() const;
    const base2_type&amp; <b><a href="#xor_combine::base2">base2</a></b>() const;
    result_type <b><a href="#xor_combine::min">min</a></b>() const;
    result_type <b><a href="#xor_combine::max">max</a></b>() const;
    result_type <b><a href="#xor_combine::operator()">operator()</a></b>();

private:
    base1_type stored_eng1;     <i>// exposition only</i>
    base2_type stored_eng2;     <i>// exposition only</i>
    };
</pre>

  <p>The template class decribes a <a href="lib_rand.html#compound%20engine">compound engine</a> that
  produces values by combining values produced by two engines. The engine's <a href=
  "lib_rand.html#state">state</a> is the state of <code>stored_eng1</code> followed by the state of
  <code>stored_eng2</code>.</p>

  <h3><code><a name="xor_combine::base1" id="xor_combine::base1">xor_combine::base1</a></code></h3>
  <pre>
const base1_type&amp; <b>base1</b>() const;
</pre>

  <p>The member function returns a reference to the stored value <code>stored_eng1</code>.</p>

  <h3><code><a name="xor_combine::base1_type" id=
  "xor_combine::base1_type">xor_combine::base1_type</a></code></h3>
  <pre>
typedef Engine1 <b>base1_type</b>;
</pre>

  <p>The type is a synonym for the template parameter <code>Engine1</code>.</p>

  <h3><code><a name="xor_combine::base2" id="xor_combine::base2">xor_combine::base2</a></code></h3>
  <pre>
const base2_type&amp; <b>base2</b>() const;
</pre>

  <p>The member function returns a reference to the stored value <code>stored_eng2</code>.</p>

  <h3><code><a name="xor_combine::base2_type" id=
  "xor_combine::base2_type">xor_combine::base2_type</a></code></h3>
  <pre>
typedef Engine1 <b>base2_type</b>;
</pre>

  <p>The type is a synonym for the template parameter <code>Engine2</code>.</p>

  <h3><code><a name="xor_combine::max" id="xor_combine::max">xor_combine::max</a></code></h3>
  <pre>
result_type <b>max</b>() const;
</pre>

  <p>The member function returns the largest value in the generated sequence.</p>

  <h3><code><a name="xor_combine::min" id="xor_combine::min">xor_combine::min</a></code></h3>
  <pre>
result_type <b>min</b>() const;
</pre>

  <p>The member function returns the smallest value in the generated sequence.</p>

  <h3><code><a name="xor_combine::operator()">operator()</a></code></h3>
  <pre>
result_type <b>operator()</b>();
</pre>

  <p>The member operator returns <code>(stored_eng1() &lt;&lt; shift1) ^ (stored_eng2() &lt;&lt;
  shift2)</code>.</p>

  <h3><code><a name="xor_combine::result_type" id=
  "xor_combine::result_type">xor_combine::result_type</a></code></h3>
  <pre>
typedef T1 <b>result_type</b>;
</pre>

  <p>The type is a synonym for the unnamed type <code>T1</code>, which is either
  <code>Engine1::result_type</code> or <code>Engine2::result_type</code>, whichever has the larger range of
  values.</p>

  <h3><code><a name="xor_combine::seed" id="xor_combine::seed">xor_combine::seed</a></code></h3>
  <pre>
void <b>seed</b>();
template&lt;class Gen&gt;
    void <b>seed</b>(Gen&amp; gen);
</pre>

  <p>The first <a href="lib_rand.html#seed%20function">seed function</a> calls
  <code>stored_eng1.seed()</code> and then calls <code>stored_eng2.seed()</code>. The second seed function
  calls <code>stored_eng1.seed(gen)</code> and then calls <code>stored_eng2.seed(gen)</code>.</p>

  <h3><code><a name="xor_combine::shift1" id="xor_combine::shift1">xor_combine::shift1</a></code></h3>
  <pre>
static constexpr int <b>shift1</b> = S1;
</pre>

  <p>The static const variable holds the value of the template argument <code>S1</code>.</p>

  <h3><code><a name="xor_combine::shift2" id="xor_combine::shift2">xor_combine::shift2</a></code></h3>
  <pre>
static constexpr int <b>shift2</b> = S2;
</pre>

  <p>The static const variable holds the value of the template argument <code>S2</code>.</p>

  <h3><code><a name="xor_combine::xor_combine" id=
  "xor_combine::xor_combine">xor_combine::xor_combine</a></code></h3>
  <pre>
<b>xor_combine</b>();
<b>xor_combine</b>(result_type x0);
<b>xor_combine</b>(const base1_type&amp; eng1, const base2_type&amp; eng2);
template&lt;class Gen&gt;
    <b>xor_combine</b>(Gen&amp; gen);
</pre>

  <p>The first constructor constructs an object with stored values <code>stored_eng1</code> and
  <code>stored_eng2</code> constructed with their respective default constructors. The second constructor
  constructs an object with stored values <code>stored_eng1</code> and <code>stored_eng2</code> constructed
  with <code>x0</code> and <code>x0 + 1</code>, respectively. The third constructor constructs an object
  whose stored value <code>stored_eng1</code> holds a copy of <code>eng1</code> and whose stored value
  <code>stored_eng2</code> holds a copy of <code>eng2</code>. The fourth constructor constructs an object and
  calls <code>seed(gen)</code>.</p>
  <hr>

  <p>See also the <b><a href="index.html#Table%20of%20Contents">Table of Contents</a></b> and the <b><a href=
  "_index.html">Index</a></b>.</p>

  <p><i><a href="crit_pjp.html">Copyright</a> &copy; 1992-2010 by Dinkumware, Ltd. All rights
  reserved.</i></p><!--V5.30:126I-->
</body>
</html>
