<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2//EN">

<html>
<head>
  <meta name="generator" content=
  "HTML Tidy for Mac OS X (vers 31 October 2006 - Apple Inc. build 15.15), see www.w3.org">

  <title>Files and Streams</title>
</head>

<body>
  <h1><a name="Files and Streams">Files and Streams</a></h1>
  <hr>

  <p><b><a href="#Text%20and%20Binary%20Streams">Text and Binary Streams</a> &middot; <a href=
  "#Controlling%20Streams">Controlling Streams</a> &middot; <a href="#Stream%20States">Stream
  States</a></b></p>
  <hr>

  <p>A program communicates with the target environment by reading and writing <b><a name=
  "files">files</a></b> (ordered sequences of bytes). A file can be, for example, a data set that you can
  read and write repeatedly (such as a disk file), a stream of bytes generated by a program (such as a
  pipeline), or a stream of bytes received from or sent to a peripheral device (such as the keyboard or
  display). The latter two are <b><a name="interactive files">interactive files</a></b>. Files are typically
  the principal means by which to interact with a program.</p>

  <p>You manipulate all these kinds of files in much the same way -- by calling library functions. You
  include the standard header <code>&lt;stdio.h&gt;</code> to declare most of these functions.</p>

  <p>Before you can perform many of the operations on a file, the file must be <b><a name=
  "file open">opened</a></b>. Opening a file associates it with a <b><a name="stream">stream</a></b>, a data
  structure within the Standard C library that glosses over many differences among files of various kinds.
  The library maintains the state of each stream in an object of type <a href=
  "stdio.html#FILE"><code>FILE</code></a>.</p>

  <p>The target environment opens three files prior to <a href="lib_over.html#program%20startup">program
  startup</a>. You can open a file by calling the library function <a href=
  "stdio.html#fopen"><code>fopen</code></a> with two arguments. The first argument is a <a href=
  "lib_over.html#filename">filename</a>, a <a href="lib_over.html#multibyte%20string">multibyte string</a>
  that the target environment uses to identify which file you want to read or write. The second argument is a
  <a href="lib_over.html#C%20string">C string</a> that specifies:</p>

  <ul>
    <li>whether you intend to read data from the file or write data to it or both</li>

    <li>whether you intend to generate new contents for the file (or create a file if it did not previously
    exist) or leave the existing contents in place</li>

    <li>whether writes to a file can alter existing contents or should only append bytes at the end of the
    file</li>

    <li>whether you want to manipulate a <a href="#text%20stream">text stream</a> or a <a href=
    "#binary%20stream">binary stream</a></li>
  </ul>

  <h2><a name="Text and Binary Streams">Text and Binary Streams</a></h2>

  <p>A <b><a name="text stream">text stream</a></b> consists of one or more <b><a name=
  "text lines">lines</a></b> of text that can be written to a text-oriented display so that they can be read.
  When reading from a text stream, the program reads an <code><i>NL</i></code> (newline) at the end of each
  line. When writing to a text stream, the program writes an <code><i>NL</i></code> to signal the end of a
  line. To match differing conventions among target environments for representing text in files, the library
  functions can alter the number and representations of characters transmitted between the program and a text
  stream.</p>

  <p>Thus, positioning within a text stream is limited. You can obtain the current <a href=
  "#file-position%20indicator">file-position indicator</a> by calling <code><a href=
  "stdio.html#fgetpos">fgetpos</a></code> or <code><a href="stdio.html#ftell">ftell</a></code>. You can
  position a text stream at a position obtained this way, or at the beginning or end of the stream, by
  calling <code><a href="stdio.html#fsetpos">fsetpos</a></code> or <code><a href=
  "stdio.html#fseek">fseek</a></code>. Any other change of position might well be not supported.</p>

  <p>For maximum portability, the program should not write:</p>

  <ul>
    <li>empty files</li>

    <li><code><i>space</i></code> characters at the end of a line</li>

    <li>partial lines (by omitting the <code><i>NL</i></code> at the end of a file)</li>

    <li>characters other than the printable characters, <code><i>NL</i></code>, and <code><i>HT</i></code>
    (horizontal tab)</li>
  </ul>

  <p>If you follow these rules, the sequence of characters you read from a text stream (either as byte or
  multibyte characters) will match the sequence of characters you wrote to the text stream when you created
  the file. Otherwise, the library functions can remove a file you create if the file is empty when you close
  it. Or they can alter or delete characters you write to the file.</p>

  <p>A <b><a name="binary stream">binary stream</a></b> consists of one or more bytes of arbitrary
  information. You can write the value stored in an arbitrary object to a (byte-oriented) binary stream and
  read exactly what was stored in the object when you wrote it. The library functions do not alter the bytes
  you transmit between the program and a binary stream. They can, however, append an arbitrary number of null
  bytes to the file that you write with a binary stream. The program must deal with these additional null
  bytes at the end of any binary stream.</p>

  <p>Thus, positioning within a binary stream is well defined, except for positioning relative to the end of
  the stream. You can obtain and alter the current <a href="#file-position%20indicator">file-position
  indicator</a> the same as for a <a href="#text%20stream">text stream</a>. Moreover, the offsets used by
  <code><a href="stdio.html#ftell">ftell</a></code> and <code><a href="stdio.html#fseek">fseek</a></code>
  count bytes from the beginning of the stream (which is byte zero), so integer arithmetic on these offsets
  yields predictable results.</p>

  <p>A <b><a name="byte stream">byte stream</a></b> treats a file as a sequence of bytes. Within the program,
  the stream looks like the same sequence of bytes, except for the possible alterations described above.</p>

  <h2><a name="Controlling Streams">Controlling Streams</a></h2>

  <p><a href="stdio.html#fopen"><code>fopen</code></a> returns the address of an object of type <a href=
  "stdio.html#FILE"><code>FILE</code></a>. You use this address as the <code>stream</code> argument to
  several library functions to perform various operations on an open file. For a byte stream, all input takes
  place as if each character is read by calling <a href="stdio.html#fgetc"><code>fgetc</code></a>, and all
  output takes place as if each character is written by calling <a href=
  "stdio.html#fputc"><code>fputc</code></a>.</p>

  <p>You can <b><a name="file close">close</a></b> a file by calling <a href=
  "stdio.html#fclose"><code>fclose</code></a>, after which the address of the <a href=
  "stdio.html#FILE"><code>FILE</code></a> object is invalid.</p>

  <p>A <a href="stdio.html#FILE"><code>FILE</code></a> object stores the state of a stream, including:</p>

  <ul>
    <li>an <b><a name="error indicator">error indicator</a></b> -- set nonzero by a function that encounters
    a read or write error</li>

    <li>an <b><a name="end-of-file indicator">end-of-file indicator</a></b> -- set nonzero by a function that
    encounters the end of the file while reading</li>

    <li>a <b><a name="file-position indicator">file-position indicator</a></b> -- specifies the next byte in
    the stream to read or write, if the file can support positioning requests</li>

    <li>a <b><a href="#Stream%20States">stream state</a></b> -- specifies whether the stream will accept
    reads and/or writes</li>

    <li>a <b><a name="file buffer">file buffer</a></b> -- specifies the address and size of an array object
    that library functions can use to improve the performance of read and write operations to the stream</li>
  </ul>

  <p>Do not alter any value stored in a <a href="stdio.html#FILE"><code>FILE</code></a> object or in a file
  buffer that you specify for use with that object. You cannot copy a <a href=
  "stdio.html#FILE"><code>FILE</code></a> object and portably use the address of the copy as a
  <code>stream</code> argument to a library function.</p>

  <h2><a name="Stream States">Stream States</a></h2>

  <p>The valid states, and state transitions, for a stream are shown in the diagram.</p>

  <p><img src="stream.gif"></p>

  <p>Each of the circles denotes a stable state. Each of the lines denotes a transition that can occur as the
  result of a function call that operates on the stream. (The ``wide'' states are never entered in the
  Embedded C++ library.) Three groups of functions can cause state transitions. All are declared in <a href=
  "stdio.html"><code>&lt;stdio.h&gt;</code></a>:</p>

  <ul>
    <li>the <b><a name="byte read functions">byte read functions</a></b> -- <a href=
    "stdio.html#fgetc"><code>fgetc</code></a>, <a href="stdio.html#fgets"><code>fgets</code></a>, <a href=
    "stdio.html#fread"><code>fread</code></a>, <a href="stdio.html#fscanf"><code>fscanf</code></a>, <a href=
    "stdio.html#getc"><code>getc</code></a>, <a href="stdio.html#getchar"><code>getchar</code></a>, <a href=
    "stdio.html#gets"><code>gets</code></a>, <a href="stdio.html#scanf"><code>scanf</code></a>, and <a href=
    "stdio.html#ungetc"><code>ungetc</code></a></li>

    <li>the <b><a name="byte write functions">byte write functions</a></b> -- <a href=
    "stdio.html#fprintf"><code>fprintf</code></a>, <a href="stdio.html#fputc"><code>fputc</code></a>,
    <a href="stdio.html#fputs"><code>fputs</code></a>, <a href="stdio.html#fwrite"><code>fwrite</code></a>,
    <a href="stdio.html#printf"><code>printf</code></a>, <a href="stdio.html#putc"><code>putc</code></a>,
    <a href="stdio.html#putchar"><code>putchar</code></a>, <a href="stdio.html#puts"><code>puts</code></a>,
    <a href="stdio.html#vfprintf"><code>vfprintf</code></a>, and <a href=
    "stdio.html#vprintf"><code>vprintf</code></a></li>

    <li>the <b><a name="position functions">position functions</a></b> -- <a href=
    "stdio.html#fflush"><code>fflush</code></a>, <a href="stdio.html#fseek"><code>fseek</code></a>, <a href=
    "stdio.html#fsetpos"><code>fsetpos</code></a>, and <a href=
    "stdio.html#rewind"><code>rewind</code></a></li>
  </ul>

  <p>The state diagram shows that you must call one of the position functions between most write and read
  operations:</p>

  <ul>
    <li>You cannot call a read function if the last operation on the stream was a write.</li>

    <li>You cannot call a write function if the last operation on the stream was a read, unless that read
    operation set the <a href="#end-of-file%20indicator">end-of-file indicator</a>.</li>
  </ul>

  <p>Finally, the state diagram shows that a position operation never <i>decreases</i> the number of valid
  function calls that can follow.</p>
  <hr>

  <p>See also the <b><a href="index.html#Table%20of%20Contents">Table of Contents</a></b> and the <b><a href=
  "_index.html">Index</a></b>.</p>

  <p><i><a href="crit_pjp.html">Copyright</a> &copy; 1992-2010 by P.J. Plauger and Jim Brodie. All rights
  reserved.</i></p><!--V5.30:126I-->
</body>
</html>
